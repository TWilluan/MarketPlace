"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that does not need to be resized, a result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */ "default", {
    enumerable: true,
    get: function() {
        return resizeAndTransformImageSizes;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _isNumber = require("../utilities/isNumber");
const _fileExists = /*#__PURE__*/ _interop_require_default(require("./fileExists"));
const _optionallyAppendMetadata = require("./optionallyAppendMetadata");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */ const getSanitizedImageData = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, _sanitizefilename.default)(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
};
const createImageName = ({ extension, height, outputImageName, width })=>{
    return `${outputImageName}-${width}x${height}.${extension}`;
};
/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */ const createResult = ({ name, filename = null, filesize = null, height = null, mimeType = null, sizesToSave = [], width = null })=>{
    return {
        sizeData: {
            [name]: {
                filename,
                filesize,
                height,
                mimeType,
                width
            }
        },
        sizesToSave
    };
};
/**
 * Determine whether or not to resize the image.
 * - resize using image config
 * - resize using image config with focal adjustments
 * - do not resize at all
 *
 * `imageResizeConfig.withoutEnlargement`:
 * - undefined [default]: uploading images with smaller width AND height than the image size will return null
 * - false: always enlarge images to the image size
 * - true: if the image is smaller than the image size, return the original image
 *
 * `imageResizeConfig.withoutReduction`:
 * - false [default]: always enlarge images to the image size
 * - true: if the image is smaller than the image size, return the original image
 *
 * @return 'omit' | 'resize' | 'resizeWithFocalPoint'
 */ const getImageResizeAction = ({ dimensions: originalImage, hasFocalPoint, imageResizeConfig })=>{
    const { fit, height: targetHeight, width: targetWidth, withoutEnlargement, withoutReduction } = imageResizeConfig;
    // prevent upscaling by default when x and y are both smaller than target image size
    if (targetHeight && targetWidth) {
        const originalImageIsSmallerXAndY = originalImage.width < targetWidth && originalImage.height < targetHeight;
        if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {
            return 'omit' // prevent image size from being enlarged
            ;
        }
    }
    const originalImageIsSmallerXOrY = originalImage.width < targetWidth || originalImage.height < targetHeight;
    if (fit === 'contain' || fit === 'inside') return 'resize';
    if (!(0, _isNumber.isNumber)(targetHeight) && !(0, _isNumber.isNumber)(targetWidth)) return 'resize';
    const targetAspectRatio = targetWidth / targetHeight;
    const originalAspectRatio = originalImage.width / originalImage.height;
    if (originalAspectRatio === targetAspectRatio) return 'resize';
    if (withoutEnlargement && originalImageIsSmallerXOrY) return 'resize';
    if (withoutReduction && !originalImageIsSmallerXOrY) return 'resize';
    return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize';
};
/**
 * Check if the image should be passed directly to sharp without payload adjusting properties.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if the image should passed directly to sharp
 */ const applyPayloadAdjustments = ({ fit, height, width, withoutEnlargement, withoutReduction }, original)=>{
    if (fit === 'contain' || fit === 'inside') return false;
    if (!(0, _isNumber.isNumber)(height) && !(0, _isNumber.isNumber)(width)) return false;
    const targetAspectRatio = width / height;
    const originalAspectRatio = original.width / original.height;
    if (originalAspectRatio === targetAspectRatio) return false;
    const skipEnlargement = withoutEnlargement && (original.height < height || original.width < width);
    const skipReduction = withoutReduction && (original.height > height || original.width > width);
    if (skipEnlargement || skipReduction) return false;
    return true;
};
/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */ const sanitizeResizeConfig = (resizeConfig)=>{
    if (resizeConfig.withoutReduction) {
        return {
            ...resizeConfig,
            // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
            fit: resizeConfig?.fit || 'contain',
            position: resizeConfig?.position || 'left top'
        };
    }
    return resizeConfig;
};
/**
 * Used to extract height from images, animated or not.
 *
 * @param sharpMetadata - the sharp metadata
 * @returns the height of the image
 */ function extractHeightFromImage(sharpMetadata) {
    if (sharpMetadata?.pages) {
        return sharpMetadata.height / sharpMetadata.pages;
    }
    return sharpMetadata.height;
}
async function resizeAndTransformImageSizes({ config, dimensions, file, mimeType, req, savedFilename, staticPath, uploadEdits, withMetadata }) {
    const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload;
    // Focal point adjustments
    const incomingFocalPoint = uploadEdits?.focalPoint ? {
        x: (0, _isNumber.isNumber)(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,
        y: (0, _isNumber.isNumber)(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50
    } : undefined;
    const defaultResult = {
        ...focalPointEnabled && incomingFocalPoint && {
            focalPoint: incomingFocalPoint
        },
        sizeData: {},
        sizesToSave: []
    };
    // Nothing to resize here so return as early as possible
    if (!imageSizes) return defaultResult;
    // Determine if the file is animated
    const fileIsAnimatedType = [
        'image/avif',
        'image/gif',
        'image/webp'
    ].includes(file.mimetype);
    const sharpOptions = {};
    if (fileIsAnimatedType) sharpOptions.animated = true;
    const sharpBase = (0, _sharp.default)(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const originalImageMeta = await sharpBase.metadata();
    const resizeImageMeta = {
        height: extractHeightFromImage(originalImageMeta),
        width: originalImageMeta.width
    };
    const results = await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        imageResizeConfig = sanitizeResizeConfig(imageResizeConfig);
        const resizeAction = getImageResizeAction({
            dimensions,
            hasFocalPoint: Boolean(incomingFocalPoint),
            imageResizeConfig
        });
        if (resizeAction === 'omit') return createResult({
            name: imageResizeConfig.name
        });
        const imageToResize = sharpBase.clone();
        let resized = imageToResize;
        if (resizeAction === 'resizeWithFocalPoint') {
            let { height: resizeHeight, width: resizeWidth } = imageResizeConfig;
            const originalAspectRatio = dimensions.width / dimensions.height;
            // Calculate resizeWidth based on original aspect ratio if it's undefined
            if (resizeHeight && !resizeWidth) {
                resizeWidth = Math.round(resizeHeight * originalAspectRatio);
            }
            // Calculate resizeHeight based on original aspect ratio if it's undefined
            if (resizeWidth && !resizeHeight) {
                resizeHeight = Math.round(resizeWidth / originalAspectRatio);
            }
            if (!resizeHeight) resizeHeight = resizeImageMeta.height;
            if (!resizeWidth) resizeWidth = resizeImageMeta.width;
            const resizeAspectRatio = resizeWidth / resizeHeight;
            const prioritizeHeight = resizeAspectRatio < originalAspectRatio;
            // Scales the image before extracting from it
            resized = imageToResize.resize({
                height: prioritizeHeight ? resizeHeight : undefined,
                width: prioritizeHeight ? undefined : resizeWidth
            });
            const metadataAppendedFile = await (0, _optionallyAppendMetadata.optionallyAppendMetadata)({
                req,
                sharpFile: resized,
                withMetadata
            });
            // Must read from buffer, resized.metadata will return the original image metadata
            const { info } = await metadataAppendedFile.toBuffer({
                resolveWithObject: true
            });
            resizeImageMeta.height = extractHeightFromImage({
                ...originalImageMeta,
                height: info.height
            });
            resizeImageMeta.width = info.width;
            const halfResizeX = resizeWidth / 2;
            const xFocalCenter = resizeImageMeta.width * (incomingFocalPoint.x / 100);
            const calculatedRightPixelBound = xFocalCenter + halfResizeX;
            let leftBound = xFocalCenter - halfResizeX;
            // if the right bound is greater than the image width, adjust the left bound
            // keeping focus on the right
            if (calculatedRightPixelBound > resizeImageMeta.width) {
                leftBound = resizeImageMeta.width - resizeWidth;
            }
            // if the left bound is less than 0, adjust the left bound to 0
            // keeping the focus on the left
            if (leftBound < 0) leftBound = 0;
            const halfResizeY = resizeHeight / 2;
            const yFocalCenter = resizeImageMeta.height * (incomingFocalPoint.y / 100);
            const calculatedBottomPixelBound = yFocalCenter + halfResizeY;
            let topBound = yFocalCenter - halfResizeY;
            // if the bottom bound is greater than the image height, adjust the top bound
            // keeping the image as far right as possible
            if (calculatedBottomPixelBound > resizeImageMeta.height) {
                topBound = resizeImageMeta.height - resizeHeight;
            }
            // if the top bound is less than 0, adjust the top bound to 0
            // keeping the image focus near the top
            if (topBound < 0) topBound = 0;
            resized = resized.extract({
                height: resizeHeight,
                left: Math.floor(leftBound),
                top: Math.floor(topBound),
                width: resizeWidth
            });
        } else {
            resized = imageToResize.resize(imageResizeConfig);
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const metadataAppendedFile = await (0, _optionallyAppendMetadata.optionallyAppendMetadata)({
            req,
            sharpFile: resized,
            withMetadata
        });
        const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({
            resolveWithObject: true
        });
        const sanitizedImage = getSanitizedImageData(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, _filetype.fromBuffer)(bufferData);
        const imageNameWithDimensions = createImageName({
            extension: mimeInfo?.ext || sanitizedImage.ext,
            height: extractHeightFromImage({
                ...originalImageMeta,
                height: bufferInfo.height
            }),
            outputImageName: sanitizedImage.name,
            width: bufferInfo.width
        });
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, _fileExists.default)(imagePath)) {
            try {
                _fs.default.unlinkSync(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        return createResult({
            name: imageResizeConfig.name,
            filename: imageNameWithDimensions,
            filesize: size,
            height: fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,
            mimeType: mimeInfo?.mime || mimeType,
            sizesToSave: [
                {
                    buffer: bufferData,
                    path: imagePath
                }
            ],
            width
        });
    }));
    return results.reduce((acc, result)=>{
        Object.assign(acc.sizeData, result.sizeData);
        acc.sizesToSave.push(...result.sizesToSave);
        return acc;
    }, {
        ...defaultResult
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2ltYWdlUmVzaXplci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSB9IGZyb20gJ2V4cHJlc3MtZmlsZXVwbG9hZCdcbmltcG9ydCB0eXBlIHsgU2hhcnAsIE1ldGFkYXRhIGFzIFNoYXJwTWV0YWRhdGEsIFNoYXJwT3B0aW9ucyB9IGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgeyBmcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJ1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgdHlwZSB7IFNhbml0aXplZENvbGxlY3Rpb25Db25maWcgfSBmcm9tICcuLi9jb2xsZWN0aW9ucy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRmlsZVNpemUsXG4gIEZpbGVTaXplcyxcbiAgRmlsZVRvU2F2ZSxcbiAgSW1hZ2VTaXplLFxuICBQcm9iZWRJbWFnZVNpemUsXG4gIFVwbG9hZEVkaXRzLFxufSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4uL3V0aWxpdGllcy9pc051bWJlcidcbmltcG9ydCBmaWxlRXhpc3RzIGZyb20gJy4vZmlsZUV4aXN0cydcbmltcG9ydCB7IHR5cGUgV2l0aE1ldGFkYXRhLCBvcHRpb25hbGx5QXBwZW5kTWV0YWRhdGEgfSBmcm9tICcuL29wdGlvbmFsbHlBcHBlbmRNZXRhZGF0YSdcblxudHlwZSBSZXNpemVBcmdzID0ge1xuICBjb25maWc6IFNhbml0aXplZENvbGxlY3Rpb25Db25maWdcbiAgZGltZW5zaW9uczogUHJvYmVkSW1hZ2VTaXplXG4gIGZpbGU6IFVwbG9hZGVkRmlsZVxuICBtaW1lVHlwZTogc3RyaW5nXG4gIHJlcTogUGF5bG9hZFJlcXVlc3RcbiAgc2F2ZWRGaWxlbmFtZTogc3RyaW5nXG4gIHN0YXRpY1BhdGg6IHN0cmluZ1xuICB1cGxvYWRFZGl0cz86IFVwbG9hZEVkaXRzXG4gIHdpdGhNZXRhZGF0YT86IFdpdGhNZXRhZGF0YVxufVxuXG4vKiogUmVzdWx0IGZyb20gcmVzaXppbmcgYW5kIHRyYW5zZm9ybWluZyB0aGUgcmVxdWVzdGVkIGltYWdlIHNpemVzICovXG50eXBlIEltYWdlU2l6ZXNSZXN1bHQgPSB7XG4gIGZvY2FsUG9pbnQ/OiBVcGxvYWRFZGl0c1snZm9jYWxQb2ludCddXG4gIHNpemVEYXRhOiBGaWxlU2l6ZXNcbiAgc2l6ZXNUb1NhdmU6IEZpbGVUb1NhdmVbXVxufVxuXG50eXBlIFNhbml0aXplZEltYWdlRGF0YSA9IHtcbiAgZXh0OiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG59XG5cbi8qKlxuICogU2FuaXRpemUgdGhlIGltYWdlIG5hbWUgYW5kIGV4dHJhY3QgdGhlIGV4dGVuc2lvbiBmcm9tIHRoZSBzb3VyY2UgaW1hZ2VcbiAqXG4gKiBAcGFyYW0gc291cmNlSW1hZ2UgLSB0aGUgc291cmNlIGltYWdlXG4gKiBAcmV0dXJucyB0aGUgc2FuaXRpemVkIG5hbWUgYW5kIGV4dGVuc2lvblxuICovXG5jb25zdCBnZXRTYW5pdGl6ZWRJbWFnZURhdGEgPSAoc291cmNlSW1hZ2U6IHN0cmluZyk6IFNhbml0aXplZEltYWdlRGF0YSA9PiB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHNvdXJjZUltYWdlLnNwbGl0KCcuJykucG9wKClcbiAgY29uc3QgbmFtZSA9IHNhbml0aXplKHNvdXJjZUltYWdlLnN1YnN0cmluZygwLCBzb3VyY2VJbWFnZS5sYXN0SW5kZXhPZignLicpKSB8fCBzb3VyY2VJbWFnZSlcbiAgcmV0dXJuIHsgbmFtZSwgZXh0OiBleHRlbnNpb24gfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbWFnZSBuYW1lIGJhc2VkIG9uIHRoZSBvdXRwdXQgaW1hZ2UgbmFtZSwgdGhlIGRpbWVuc2lvbnMgYW5kXG4gKiB0aGUgZXh0ZW5zaW9uLlxuICpcbiAqIElnbm9yZSB0aGUgZmFjdCB0aGF0IGR1cGxpY2F0ZSBuYW1lcyBjb3VsZCBoYXBwZW4gaWYgdGhlIHRoZXJlIGlzIG9uZVxuICogc2l6ZSB3aXRoIGB3aWR0aCBBTkQgaGVpZ2h0YCBhbmQgb25lIHdpdGggb25seSBgaGVpZ2h0IE9SIHdpZHRoYC4gQmVjYXVzZVxuICogc3BhY2UgaXMgZXhwZW5zaXZlLCB3ZSB3aWxsIHJldXNlIHRoZSBzYW1lIGltYWdlIGZvciBib3RoIHNpemVzLlxuICpcbiAqIEBwYXJhbSBvdXRwdXRJbWFnZU5hbWUgLSB0aGUgc2FuaXRpemVkIGltYWdlIG5hbWVcbiAqIEBwYXJhbSBidWZmZXJJbmZvIC0gdGhlIGJ1ZmZlciBpbmZvXG4gKiBAcGFyYW0gZXh0ZW5zaW9uIC0gdGhlIGV4dGVuc2lvbiB0byB1c2VcbiAqIEByZXR1cm5zIHRoZSBuZXcgaW1hZ2UgbmFtZSB0aGF0IGlzIG5vdCB0YWtlblxuICovXG5cbnR5cGUgQ3JlYXRlSW1hZ2VOYW1lQXJncyA9IHtcbiAgZXh0ZW5zaW9uOiBzdHJpbmdcbiAgaGVpZ2h0OiBudW1iZXJcbiAgb3V0cHV0SW1hZ2VOYW1lOiBzdHJpbmdcbiAgd2lkdGg6IG51bWJlclxufVxuY29uc3QgY3JlYXRlSW1hZ2VOYW1lID0gKHtcbiAgZXh0ZW5zaW9uLFxuICBoZWlnaHQsXG4gIG91dHB1dEltYWdlTmFtZSxcbiAgd2lkdGgsXG59OiBDcmVhdGVJbWFnZU5hbWVBcmdzKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGAke291dHB1dEltYWdlTmFtZX0tJHt3aWR0aH14JHtoZWlnaHR9LiR7ZXh0ZW5zaW9ufWBcbn1cblxudHlwZSBDcmVhdGVSZXN1bHRBcmdzID0ge1xuICBmaWxlbmFtZT86IEZpbGVTaXplWydmaWxlbmFtZSddXG4gIGZpbGVzaXplPzogRmlsZVNpemVbJ2ZpbGVzaXplJ11cbiAgaGVpZ2h0PzogRmlsZVNpemVbJ2hlaWdodCddXG4gIG1pbWVUeXBlPzogRmlsZVNpemVbJ21pbWVUeXBlJ11cbiAgbmFtZTogc3RyaW5nXG4gIHNpemVzVG9TYXZlPzogRmlsZVRvU2F2ZVtdXG4gIHdpZHRoPzogRmlsZVNpemVbJ3dpZHRoJ11cbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIHJlc3VsdCBvYmplY3QgZm9yIHRoZSBpbWFnZSByZXNpemUgb3BlcmF0aW9uIGJhc2VkIG9uIHRoZVxuICogcHJvdmlkZWQgcGFyYW1ldGVycy4gSWYgdGhlIG5hbWUgaXMgbm90IHByb3ZpZGVkLCBhbiBlbXB0eSByZXN1bHQgb2JqZWN0XG4gKiBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIGZpbGVuYW1lIC0gdGhlIGZpbGVuYW1lIG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gZmlsZXNpemUgLSB0aGUgZmlsZXNpemUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gbWltZVR5cGUgLSB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIHNpemVzVG9TYXZlIC0gdGhlIHNpemVzIHRvIHNhdmVcbiAqIEByZXR1cm5zIHRoZSByZXN1bHQgb2JqZWN0XG4gKi9cbmNvbnN0IGNyZWF0ZVJlc3VsdCA9ICh7XG4gIG5hbWUsXG4gIGZpbGVuYW1lID0gbnVsbCxcbiAgZmlsZXNpemUgPSBudWxsLFxuICBoZWlnaHQgPSBudWxsLFxuICBtaW1lVHlwZSA9IG51bGwsXG4gIHNpemVzVG9TYXZlID0gW10sXG4gIHdpZHRoID0gbnVsbCxcbn06IENyZWF0ZVJlc3VsdEFyZ3MpOiBJbWFnZVNpemVzUmVzdWx0ID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzaXplRGF0YToge1xuICAgICAgW25hbWVdOiB7XG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBmaWxlc2l6ZSxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgd2lkdGgsXG4gICAgICB9LFxuICAgIH0sXG4gICAgc2l6ZXNUb1NhdmUsXG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gcmVzaXplIHRoZSBpbWFnZS5cbiAqIC0gcmVzaXplIHVzaW5nIGltYWdlIGNvbmZpZ1xuICogLSByZXNpemUgdXNpbmcgaW1hZ2UgY29uZmlnIHdpdGggZm9jYWwgYWRqdXN0bWVudHNcbiAqIC0gZG8gbm90IHJlc2l6ZSBhdCBhbGxcbiAqXG4gKiBgaW1hZ2VSZXNpemVDb25maWcud2l0aG91dEVubGFyZ2VtZW50YDpcbiAqIC0gdW5kZWZpbmVkIFtkZWZhdWx0XTogdXBsb2FkaW5nIGltYWdlcyB3aXRoIHNtYWxsZXIgd2lkdGggQU5EIGhlaWdodCB0aGFuIHRoZSBpbWFnZSBzaXplIHdpbGwgcmV0dXJuIG51bGxcbiAqIC0gZmFsc2U6IGFsd2F5cyBlbmxhcmdlIGltYWdlcyB0byB0aGUgaW1hZ2Ugc2l6ZVxuICogLSB0cnVlOiBpZiB0aGUgaW1hZ2UgaXMgc21hbGxlciB0aGFuIHRoZSBpbWFnZSBzaXplLCByZXR1cm4gdGhlIG9yaWdpbmFsIGltYWdlXG4gKlxuICogYGltYWdlUmVzaXplQ29uZmlnLndpdGhvdXRSZWR1Y3Rpb25gOlxuICogLSBmYWxzZSBbZGVmYXVsdF06IGFsd2F5cyBlbmxhcmdlIGltYWdlcyB0byB0aGUgaW1hZ2Ugc2l6ZVxuICogLSB0cnVlOiBpZiB0aGUgaW1hZ2UgaXMgc21hbGxlciB0aGFuIHRoZSBpbWFnZSBzaXplLCByZXR1cm4gdGhlIG9yaWdpbmFsIGltYWdlXG4gKlxuICogQHJldHVybiAnb21pdCcgfCAncmVzaXplJyB8ICdyZXNpemVXaXRoRm9jYWxQb2ludCdcbiAqL1xuY29uc3QgZ2V0SW1hZ2VSZXNpemVBY3Rpb24gPSAoe1xuICBkaW1lbnNpb25zOiBvcmlnaW5hbEltYWdlLFxuICBoYXNGb2NhbFBvaW50LFxuICBpbWFnZVJlc2l6ZUNvbmZpZyxcbn06IHtcbiAgZGltZW5zaW9uczogUHJvYmVkSW1hZ2VTaXplXG4gIGhhc0ZvY2FsUG9pbnQ/OiBib29sZWFuXG4gIGltYWdlUmVzaXplQ29uZmlnOiBJbWFnZVNpemVcbn0pOiAnb21pdCcgfCAncmVzaXplJyB8ICdyZXNpemVXaXRoRm9jYWxQb2ludCcgPT4ge1xuICBjb25zdCB7XG4gICAgZml0LFxuICAgIGhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuICAgIHdpZHRoOiB0YXJnZXRXaWR0aCxcbiAgICB3aXRob3V0RW5sYXJnZW1lbnQsXG4gICAgd2l0aG91dFJlZHVjdGlvbixcbiAgfSA9IGltYWdlUmVzaXplQ29uZmlnXG5cbiAgLy8gcHJldmVudCB1cHNjYWxpbmcgYnkgZGVmYXVsdCB3aGVuIHggYW5kIHkgYXJlIGJvdGggc21hbGxlciB0aGFuIHRhcmdldCBpbWFnZSBzaXplXG4gIGlmICh0YXJnZXRIZWlnaHQgJiYgdGFyZ2V0V2lkdGgpIHtcbiAgICBjb25zdCBvcmlnaW5hbEltYWdlSXNTbWFsbGVyWEFuZFkgPVxuICAgICAgb3JpZ2luYWxJbWFnZS53aWR0aCA8IHRhcmdldFdpZHRoICYmIG9yaWdpbmFsSW1hZ2UuaGVpZ2h0IDwgdGFyZ2V0SGVpZ2h0XG4gICAgaWYgKHdpdGhvdXRFbmxhcmdlbWVudCA9PT0gdW5kZWZpbmVkICYmIG9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYQW5kWSkge1xuICAgICAgcmV0dXJuICdvbWl0JyAvLyBwcmV2ZW50IGltYWdlIHNpemUgZnJvbSBiZWluZyBlbmxhcmdlZFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYT3JZID1cbiAgICBvcmlnaW5hbEltYWdlLndpZHRoIDwgdGFyZ2V0V2lkdGggfHwgb3JpZ2luYWxJbWFnZS5oZWlnaHQgPCB0YXJnZXRIZWlnaHRcbiAgaWYgKGZpdCA9PT0gJ2NvbnRhaW4nIHx8IGZpdCA9PT0gJ2luc2lkZScpIHJldHVybiAncmVzaXplJ1xuICBpZiAoIWlzTnVtYmVyKHRhcmdldEhlaWdodCkgJiYgIWlzTnVtYmVyKHRhcmdldFdpZHRoKSkgcmV0dXJuICdyZXNpemUnXG5cbiAgY29uc3QgdGFyZ2V0QXNwZWN0UmF0aW8gPSB0YXJnZXRXaWR0aCAvIHRhcmdldEhlaWdodFxuICBjb25zdCBvcmlnaW5hbEFzcGVjdFJhdGlvID0gb3JpZ2luYWxJbWFnZS53aWR0aCAvIG9yaWdpbmFsSW1hZ2UuaGVpZ2h0XG4gIGlmIChvcmlnaW5hbEFzcGVjdFJhdGlvID09PSB0YXJnZXRBc3BlY3RSYXRpbykgcmV0dXJuICdyZXNpemUnXG5cbiAgaWYgKHdpdGhvdXRFbmxhcmdlbWVudCAmJiBvcmlnaW5hbEltYWdlSXNTbWFsbGVyWE9yWSkgcmV0dXJuICdyZXNpemUnXG4gIGlmICh3aXRob3V0UmVkdWN0aW9uICYmICFvcmlnaW5hbEltYWdlSXNTbWFsbGVyWE9yWSkgcmV0dXJuICdyZXNpemUnXG5cbiAgcmV0dXJuIGhhc0ZvY2FsUG9pbnQgPyAncmVzaXplV2l0aEZvY2FsUG9pbnQnIDogJ3Jlc2l6ZSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW1hZ2Ugc2hvdWxkIGJlIHBhc3NlZCBkaXJlY3RseSB0byBzaGFycCB3aXRob3V0IHBheWxvYWQgYWRqdXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHJlc2l6ZUNvbmZpZyAtIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0ZWQgZGltZW5zaW9ucyBhbmQgcmVzaXplIG9wdGlvbnNcbiAqIEBwYXJhbSBvcmlnaW5hbCAtIHRoZSBvcmlnaW5hbCBpbWFnZSBzaXplXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBpbWFnZSBzaG91bGQgcGFzc2VkIGRpcmVjdGx5IHRvIHNoYXJwXG4gKi9cbmNvbnN0IGFwcGx5UGF5bG9hZEFkanVzdG1lbnRzID0gKFxuICB7IGZpdCwgaGVpZ2h0LCB3aWR0aCwgd2l0aG91dEVubGFyZ2VtZW50LCB3aXRob3V0UmVkdWN0aW9uIH06IEltYWdlU2l6ZSxcbiAgb3JpZ2luYWw6IFByb2JlZEltYWdlU2l6ZSxcbikgPT4ge1xuICBpZiAoZml0ID09PSAnY29udGFpbicgfHwgZml0ID09PSAnaW5zaWRlJykgcmV0dXJuIGZhbHNlXG4gIGlmICghaXNOdW1iZXIoaGVpZ2h0KSAmJiAhaXNOdW1iZXIod2lkdGgpKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCB0YXJnZXRBc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0XG4gIGNvbnN0IG9yaWdpbmFsQXNwZWN0UmF0aW8gPSBvcmlnaW5hbC53aWR0aCAvIG9yaWdpbmFsLmhlaWdodFxuICBpZiAob3JpZ2luYWxBc3BlY3RSYXRpbyA9PT0gdGFyZ2V0QXNwZWN0UmF0aW8pIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHNraXBFbmxhcmdlbWVudCA9IHdpdGhvdXRFbmxhcmdlbWVudCAmJiAob3JpZ2luYWwuaGVpZ2h0IDwgaGVpZ2h0IHx8IG9yaWdpbmFsLndpZHRoIDwgd2lkdGgpXG4gIGNvbnN0IHNraXBSZWR1Y3Rpb24gPSB3aXRob3V0UmVkdWN0aW9uICYmIChvcmlnaW5hbC5oZWlnaHQgPiBoZWlnaHQgfHwgb3JpZ2luYWwud2lkdGggPiB3aWR0aClcbiAgaWYgKHNraXBFbmxhcmdlbWVudCB8fCBza2lwUmVkdWN0aW9uKSByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIFNhbml0aXplIHRoZSByZXNpemUgY29uZmlnLiBJZiB0aGUgcmVzaXplIGNvbmZpZyBoYXMgdGhlIGB3aXRob3V0UmVkdWN0aW9uYFxuICogcHJvcGVydHkgc2V0IHRvIHRydWUsIHRoZSBgZml0YCBhbmQgYHBvc2l0aW9uYCBwcm9wZXJ0aWVzIHdpbGwgYmUgc2V0IHRvIGBjb250YWluYFxuICogYW5kIGB0b3AgbGVmdGAgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBwYXJhbSByZXNpemVDb25maWcgLSB0aGUgcmVzaXplIGNvbmZpZ1xuICogQHJldHVybnMgYSBzYW5pdGl6ZWQgcmVzaXplIGNvbmZpZ1xuICovXG5jb25zdCBzYW5pdGl6ZVJlc2l6ZUNvbmZpZyA9IChyZXNpemVDb25maWc6IEltYWdlU2l6ZSk6IEltYWdlU2l6ZSA9PiB7XG4gIGlmIChyZXNpemVDb25maWcud2l0aG91dFJlZHVjdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNpemVDb25maWcsXG4gICAgICAvLyBXaHkgZml0IGBjb250YWluYCBzaG91bGQgYWxzbyBiZSBzZXQgdG8gaHR0cHM6Ly9naXRodWIuY29tL2xvdmVsbC9zaGFycC9pc3N1ZXMvMzU5NVxuICAgICAgZml0OiByZXNpemVDb25maWc/LmZpdCB8fCAnY29udGFpbicsXG4gICAgICBwb3NpdGlvbjogcmVzaXplQ29uZmlnPy5wb3NpdGlvbiB8fCAnbGVmdCB0b3AnLFxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzaXplQ29uZmlnXG59XG5cbi8qKlxuICogVXNlZCB0byBleHRyYWN0IGhlaWdodCBmcm9tIGltYWdlcywgYW5pbWF0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBzaGFycE1ldGFkYXRhIC0gdGhlIHNoYXJwIG1ldGFkYXRhXG4gKiBAcmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICovXG5mdW5jdGlvbiBleHRyYWN0SGVpZ2h0RnJvbUltYWdlKHNoYXJwTWV0YWRhdGE6IFNoYXJwTWV0YWRhdGEpOiBudW1iZXIge1xuICBpZiAoc2hhcnBNZXRhZGF0YT8ucGFnZXMpIHtcbiAgICByZXR1cm4gc2hhcnBNZXRhZGF0YS5oZWlnaHQgLyBzaGFycE1ldGFkYXRhLnBhZ2VzXG4gIH1cbiAgcmV0dXJuIHNoYXJwTWV0YWRhdGEuaGVpZ2h0XG59XG5cbi8qKlxuICogRm9yIHRoZSBwcm92aWRlZCBpbWFnZSBzaXplcywgaGFuZGxlIHRoZSByZXNpemluZyBhbmQgdGhlIHRyYW5zZm9ybXNcbiAqIChmb3JtYXQsIHRyaW0sIGV0Yy4pIG9mIGVhY2ggcmVxdWVzdGVkIGltYWdlIHNpemUgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9iamVjdC5cbiAqIFRoaXMgb25seSBoYW5kbGVzIHRoZSBpbWFnZSBzaXplcy4gVGhlIHRyYW5zZm9ybXMgb2YgdGhlIG9yaWdpbmFsIGltYWdlXG4gKiBhcmUgaGFuZGxlZCBpbiB7QGxpbmsgLi9nZW5lcmF0ZUZpbGVEYXRhLnRzfS5cbiAqXG4gKiBUaGUgaW1hZ2Ugd2lsbCBiZSByZXNpemVkIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWRcbiAqIHJlc2l6ZSBjb25maWcuIElmIG5vIGltYWdlIHNpemVzIGFyZSByZXF1ZXN0ZWQsIHRoZSByZXNvbHZlZCBkYXRhIHdpbGwgYmUgZW1wdHkuXG4gKiBGb3IgZXZlcnkgaW1hZ2UgdGhhdCBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlc2l6ZWQsIGEgcmVzdWx0IG9iamVjdCB3aXRoIGBudWxsYFxuICogcGFyYW1ldGVycyB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSByZXNpemVDb25maWcgLSB0aGUgcmVzaXplIGNvbmZpZ1xuICogQHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgcmVzaXplIG9wZXJhdGlvbihzKVxuICovXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiByZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzKHtcbiAgY29uZmlnLFxuICBkaW1lbnNpb25zLFxuICBmaWxlLFxuICBtaW1lVHlwZSxcbiAgcmVxLFxuICBzYXZlZEZpbGVuYW1lLFxuICBzdGF0aWNQYXRoLFxuICB1cGxvYWRFZGl0cyxcbiAgd2l0aE1ldGFkYXRhLFxufTogUmVzaXplQXJncyk6IFByb21pc2U8SW1hZ2VTaXplc1Jlc3VsdD4ge1xuICBjb25zdCB7IGZvY2FsUG9pbnQ6IGZvY2FsUG9pbnRFbmFibGVkID0gdHJ1ZSwgaW1hZ2VTaXplcyB9ID0gY29uZmlnLnVwbG9hZFxuXG4gIC8vIEZvY2FsIHBvaW50IGFkanVzdG1lbnRzXG4gIGNvbnN0IGluY29taW5nRm9jYWxQb2ludCA9IHVwbG9hZEVkaXRzPy5mb2NhbFBvaW50XG4gICAgPyB7XG4gICAgICAgIHg6IGlzTnVtYmVyKHVwbG9hZEVkaXRzLmZvY2FsUG9pbnQueCkgPyBNYXRoLnJvdW5kKHVwbG9hZEVkaXRzLmZvY2FsUG9pbnQueCkgOiA1MCxcbiAgICAgICAgeTogaXNOdW1iZXIodXBsb2FkRWRpdHMuZm9jYWxQb2ludC55KSA/IE1hdGgucm91bmQodXBsb2FkRWRpdHMuZm9jYWxQb2ludC55KSA6IDUwLFxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkXG5cbiAgY29uc3QgZGVmYXVsdFJlc3VsdDogSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgICAuLi4oZm9jYWxQb2ludEVuYWJsZWQgJiYgaW5jb21pbmdGb2NhbFBvaW50ICYmIHsgZm9jYWxQb2ludDogaW5jb21pbmdGb2NhbFBvaW50IH0pLFxuICAgIHNpemVEYXRhOiB7fSxcbiAgICBzaXplc1RvU2F2ZTogW10sXG4gIH1cblxuICAvLyBOb3RoaW5nIHRvIHJlc2l6ZSBoZXJlIHNvIHJldHVybiBhcyBlYXJseSBhcyBwb3NzaWJsZVxuICBpZiAoIWltYWdlU2l6ZXMpIHJldHVybiBkZWZhdWx0UmVzdWx0XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBmaWxlIGlzIGFuaW1hdGVkXG4gIGNvbnN0IGZpbGVJc0FuaW1hdGVkVHlwZSA9IFsnaW1hZ2UvYXZpZicsICdpbWFnZS9naWYnLCAnaW1hZ2Uvd2VicCddLmluY2x1ZGVzKGZpbGUubWltZXR5cGUpXG4gIGNvbnN0IHNoYXJwT3B0aW9uczogU2hhcnBPcHRpb25zID0ge31cblxuICBpZiAoZmlsZUlzQW5pbWF0ZWRUeXBlKSBzaGFycE9wdGlvbnMuYW5pbWF0ZWQgPSB0cnVlXG5cbiAgY29uc3Qgc2hhcnBCYXNlOiBTaGFycCB8IHVuZGVmaW5lZCA9IHNoYXJwKGZpbGUudGVtcEZpbGVQYXRoIHx8IGZpbGUuZGF0YSwgc2hhcnBPcHRpb25zKS5yb3RhdGUoKSAvLyBwYXNzIHJvdGF0ZSgpIHRvIGF1dG8tcm90YXRlIGJhc2VkIG9uIEVYSUYgZGF0YS4gaHR0cHM6Ly9naXRodWIuY29tL3BheWxvYWRjbXMvcGF5bG9hZC9wdWxsLzMwODFcbiAgY29uc3Qgb3JpZ2luYWxJbWFnZU1ldGEgPSBhd2FpdCBzaGFycEJhc2UubWV0YWRhdGEoKVxuXG4gIGNvbnN0IHJlc2l6ZUltYWdlTWV0YSA9IHtcbiAgICBoZWlnaHQ6IGV4dHJhY3RIZWlnaHRGcm9tSW1hZ2Uob3JpZ2luYWxJbWFnZU1ldGEpLFxuICAgIHdpZHRoOiBvcmlnaW5hbEltYWdlTWV0YS53aWR0aCxcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdHM6IEltYWdlU2l6ZXNSZXN1bHRbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGltYWdlU2l6ZXMubWFwKGFzeW5jIChpbWFnZVJlc2l6ZUNvbmZpZyk6IFByb21pc2U8SW1hZ2VTaXplc1Jlc3VsdD4gPT4ge1xuICAgICAgaW1hZ2VSZXNpemVDb25maWcgPSBzYW5pdGl6ZVJlc2l6ZUNvbmZpZyhpbWFnZVJlc2l6ZUNvbmZpZylcblxuICAgICAgY29uc3QgcmVzaXplQWN0aW9uID0gZ2V0SW1hZ2VSZXNpemVBY3Rpb24oe1xuICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICBoYXNGb2NhbFBvaW50OiBCb29sZWFuKGluY29taW5nRm9jYWxQb2ludCksXG4gICAgICAgIGltYWdlUmVzaXplQ29uZmlnLFxuICAgICAgfSlcbiAgICAgIGlmIChyZXNpemVBY3Rpb24gPT09ICdvbWl0JykgcmV0dXJuIGNyZWF0ZVJlc3VsdCh7IG5hbWU6IGltYWdlUmVzaXplQ29uZmlnLm5hbWUgfSlcblxuICAgICAgY29uc3QgaW1hZ2VUb1Jlc2l6ZSA9IHNoYXJwQmFzZS5jbG9uZSgpXG4gICAgICBsZXQgcmVzaXplZCA9IGltYWdlVG9SZXNpemVcblxuICAgICAgaWYgKHJlc2l6ZUFjdGlvbiA9PT0gJ3Jlc2l6ZVdpdGhGb2NhbFBvaW50Jykge1xuICAgICAgICBsZXQgeyBoZWlnaHQ6IHJlc2l6ZUhlaWdodCwgd2lkdGg6IHJlc2l6ZVdpZHRoIH0gPSBpbWFnZVJlc2l6ZUNvbmZpZ1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQXNwZWN0UmF0aW8gPSBkaW1lbnNpb25zLndpZHRoIC8gZGltZW5zaW9ucy5oZWlnaHRcblxuICAgICAgICAvLyBDYWxjdWxhdGUgcmVzaXplV2lkdGggYmFzZWQgb24gb3JpZ2luYWwgYXNwZWN0IHJhdGlvIGlmIGl0J3MgdW5kZWZpbmVkXG4gICAgICAgIGlmIChyZXNpemVIZWlnaHQgJiYgIXJlc2l6ZVdpZHRoKSB7XG4gICAgICAgICAgcmVzaXplV2lkdGggPSBNYXRoLnJvdW5kKHJlc2l6ZUhlaWdodCAqIG9yaWdpbmFsQXNwZWN0UmF0aW8pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgcmVzaXplSGVpZ2h0IGJhc2VkIG9uIG9yaWdpbmFsIGFzcGVjdCByYXRpbyBpZiBpdCdzIHVuZGVmaW5lZFxuICAgICAgICBpZiAocmVzaXplV2lkdGggJiYgIXJlc2l6ZUhlaWdodCkge1xuICAgICAgICAgIHJlc2l6ZUhlaWdodCA9IE1hdGgucm91bmQocmVzaXplV2lkdGggLyBvcmlnaW5hbEFzcGVjdFJhdGlvKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNpemVIZWlnaHQpIHJlc2l6ZUhlaWdodCA9IHJlc2l6ZUltYWdlTWV0YS5oZWlnaHRcbiAgICAgICAgaWYgKCFyZXNpemVXaWR0aCkgcmVzaXplV2lkdGggPSByZXNpemVJbWFnZU1ldGEud2lkdGhcblxuICAgICAgICBjb25zdCByZXNpemVBc3BlY3RSYXRpbyA9IHJlc2l6ZVdpZHRoIC8gcmVzaXplSGVpZ2h0XG4gICAgICAgIGNvbnN0IHByaW9yaXRpemVIZWlnaHQgPSByZXNpemVBc3BlY3RSYXRpbyA8IG9yaWdpbmFsQXNwZWN0UmF0aW9cbiAgICAgICAgLy8gU2NhbGVzIHRoZSBpbWFnZSBiZWZvcmUgZXh0cmFjdGluZyBmcm9tIGl0XG4gICAgICAgIHJlc2l6ZWQgPSBpbWFnZVRvUmVzaXplLnJlc2l6ZSh7XG4gICAgICAgICAgaGVpZ2h0OiBwcmlvcml0aXplSGVpZ2h0ID8gcmVzaXplSGVpZ2h0IDogdW5kZWZpbmVkLFxuICAgICAgICAgIHdpZHRoOiBwcmlvcml0aXplSGVpZ2h0ID8gdW5kZWZpbmVkIDogcmVzaXplV2lkdGgsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgbWV0YWRhdGFBcHBlbmRlZEZpbGUgPSBhd2FpdCBvcHRpb25hbGx5QXBwZW5kTWV0YWRhdGEoe1xuICAgICAgICAgIHJlcSxcbiAgICAgICAgICBzaGFycEZpbGU6IHJlc2l6ZWQsXG4gICAgICAgICAgd2l0aE1ldGFkYXRhLFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIE11c3QgcmVhZCBmcm9tIGJ1ZmZlciwgcmVzaXplZC5tZXRhZGF0YSB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgaW1hZ2UgbWV0YWRhdGFcbiAgICAgICAgY29uc3QgeyBpbmZvIH0gPSBhd2FpdCBtZXRhZGF0YUFwcGVuZGVkRmlsZS50b0J1ZmZlcih7IHJlc29sdmVXaXRoT2JqZWN0OiB0cnVlIH0pXG5cbiAgICAgICAgcmVzaXplSW1hZ2VNZXRhLmhlaWdodCA9IGV4dHJhY3RIZWlnaHRGcm9tSW1hZ2Uoe1xuICAgICAgICAgIC4uLm9yaWdpbmFsSW1hZ2VNZXRhLFxuICAgICAgICAgIGhlaWdodDogaW5mby5oZWlnaHQsXG4gICAgICAgIH0pXG4gICAgICAgIHJlc2l6ZUltYWdlTWV0YS53aWR0aCA9IGluZm8ud2lkdGhcblxuICAgICAgICBjb25zdCBoYWxmUmVzaXplWCA9IHJlc2l6ZVdpZHRoIC8gMlxuICAgICAgICBjb25zdCB4Rm9jYWxDZW50ZXIgPSByZXNpemVJbWFnZU1ldGEud2lkdGggKiAoaW5jb21pbmdGb2NhbFBvaW50LnggLyAxMDApXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRSaWdodFBpeGVsQm91bmQgPSB4Rm9jYWxDZW50ZXIgKyBoYWxmUmVzaXplWFxuICAgICAgICBsZXQgbGVmdEJvdW5kID0geEZvY2FsQ2VudGVyIC0gaGFsZlJlc2l6ZVhcblxuICAgICAgICAvLyBpZiB0aGUgcmlnaHQgYm91bmQgaXMgZ3JlYXRlciB0aGFuIHRoZSBpbWFnZSB3aWR0aCwgYWRqdXN0IHRoZSBsZWZ0IGJvdW5kXG4gICAgICAgIC8vIGtlZXBpbmcgZm9jdXMgb24gdGhlIHJpZ2h0XG4gICAgICAgIGlmIChjYWxjdWxhdGVkUmlnaHRQaXhlbEJvdW5kID4gcmVzaXplSW1hZ2VNZXRhLndpZHRoKSB7XG4gICAgICAgICAgbGVmdEJvdW5kID0gcmVzaXplSW1hZ2VNZXRhLndpZHRoIC0gcmVzaXplV2lkdGhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBsZWZ0IGJvdW5kIGlzIGxlc3MgdGhhbiAwLCBhZGp1c3QgdGhlIGxlZnQgYm91bmQgdG8gMFxuICAgICAgICAvLyBrZWVwaW5nIHRoZSBmb2N1cyBvbiB0aGUgbGVmdFxuICAgICAgICBpZiAobGVmdEJvdW5kIDwgMCkgbGVmdEJvdW5kID0gMFxuXG4gICAgICAgIGNvbnN0IGhhbGZSZXNpemVZID0gcmVzaXplSGVpZ2h0IC8gMlxuICAgICAgICBjb25zdCB5Rm9jYWxDZW50ZXIgPSByZXNpemVJbWFnZU1ldGEuaGVpZ2h0ICogKGluY29taW5nRm9jYWxQb2ludC55IC8gMTAwKVxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQm90dG9tUGl4ZWxCb3VuZCA9IHlGb2NhbENlbnRlciArIGhhbGZSZXNpemVZXG4gICAgICAgIGxldCB0b3BCb3VuZCA9IHlGb2NhbENlbnRlciAtIGhhbGZSZXNpemVZXG5cbiAgICAgICAgLy8gaWYgdGhlIGJvdHRvbSBib3VuZCBpcyBncmVhdGVyIHRoYW4gdGhlIGltYWdlIGhlaWdodCwgYWRqdXN0IHRoZSB0b3AgYm91bmRcbiAgICAgICAgLy8ga2VlcGluZyB0aGUgaW1hZ2UgYXMgZmFyIHJpZ2h0IGFzIHBvc3NpYmxlXG4gICAgICAgIGlmIChjYWxjdWxhdGVkQm90dG9tUGl4ZWxCb3VuZCA+IHJlc2l6ZUltYWdlTWV0YS5oZWlnaHQpIHtcbiAgICAgICAgICB0b3BCb3VuZCA9IHJlc2l6ZUltYWdlTWV0YS5oZWlnaHQgLSByZXNpemVIZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSB0b3AgYm91bmQgaXMgbGVzcyB0aGFuIDAsIGFkanVzdCB0aGUgdG9wIGJvdW5kIHRvIDBcbiAgICAgICAgLy8ga2VlcGluZyB0aGUgaW1hZ2UgZm9jdXMgbmVhciB0aGUgdG9wXG4gICAgICAgIGlmICh0b3BCb3VuZCA8IDApIHRvcEJvdW5kID0gMFxuXG4gICAgICAgIHJlc2l6ZWQgPSByZXNpemVkLmV4dHJhY3Qoe1xuICAgICAgICAgIGhlaWdodDogcmVzaXplSGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IE1hdGguZmxvb3IobGVmdEJvdW5kKSxcbiAgICAgICAgICB0b3A6IE1hdGguZmxvb3IodG9wQm91bmQpLFxuICAgICAgICAgIHdpZHRoOiByZXNpemVXaWR0aCxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2l6ZWQgPSBpbWFnZVRvUmVzaXplLnJlc2l6ZShpbWFnZVJlc2l6ZUNvbmZpZylcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMpIHtcbiAgICAgICAgcmVzaXplZCA9IHJlc2l6ZWQudG9Gb3JtYXQoXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5vcHRpb25zLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZVJlc2l6ZUNvbmZpZy50cmltT3B0aW9ucykge1xuICAgICAgICByZXNpemVkID0gcmVzaXplZC50cmltKGltYWdlUmVzaXplQ29uZmlnLnRyaW1PcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtZXRhZGF0YUFwcGVuZGVkRmlsZSA9IGF3YWl0IG9wdGlvbmFsbHlBcHBlbmRNZXRhZGF0YSh7XG4gICAgICAgIHJlcSxcbiAgICAgICAgc2hhcnBGaWxlOiByZXNpemVkLFxuICAgICAgICB3aXRoTWV0YWRhdGEsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IGRhdGE6IGJ1ZmZlckRhdGEsIGluZm86IGJ1ZmZlckluZm8gfSA9IGF3YWl0IG1ldGFkYXRhQXBwZW5kZWRGaWxlLnRvQnVmZmVyKHtcbiAgICAgICAgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBzYW5pdGl6ZWRJbWFnZSA9IGdldFNhbml0aXplZEltYWdlRGF0YShzYXZlZEZpbGVuYW1lKVxuXG4gICAgICBpZiAocmVxLnBheWxvYWRVcGxvYWRTaXplcykge1xuICAgICAgICByZXEucGF5bG9hZFVwbG9hZFNpemVzW2ltYWdlUmVzaXplQ29uZmlnLm5hbWVdID0gYnVmZmVyRGF0YVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtaW1lSW5mbyA9IGF3YWl0IGZyb21CdWZmZXIoYnVmZmVyRGF0YSlcblxuICAgICAgY29uc3QgaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMgPSBjcmVhdGVJbWFnZU5hbWUoe1xuICAgICAgICBleHRlbnNpb246IG1pbWVJbmZvPy5leHQgfHwgc2FuaXRpemVkSW1hZ2UuZXh0LFxuICAgICAgICBoZWlnaHQ6IGV4dHJhY3RIZWlnaHRGcm9tSW1hZ2Uoe1xuICAgICAgICAgIC4uLm9yaWdpbmFsSW1hZ2VNZXRhLFxuICAgICAgICAgIGhlaWdodDogYnVmZmVySW5mby5oZWlnaHQsXG4gICAgICAgIH0pLFxuICAgICAgICBvdXRwdXRJbWFnZU5hbWU6IHNhbml0aXplZEltYWdlLm5hbWUsXG4gICAgICAgIHdpZHRoOiBidWZmZXJJbmZvLndpZHRoLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgaW1hZ2VQYXRoID0gYCR7c3RhdGljUGF0aH0vJHtpbWFnZU5hbWVXaXRoRGltZW5zaW9uc31gXG5cbiAgICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKGltYWdlUGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy51bmxpbmtTeW5jKGltYWdlUGF0aClcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gSWdub3JlIHVubGluayBlcnJvcnNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGhlaWdodCwgc2l6ZSwgd2lkdGggfSA9IGJ1ZmZlckluZm9cbiAgICAgIHJldHVybiBjcmVhdGVSZXN1bHQoe1xuICAgICAgICBuYW1lOiBpbWFnZVJlc2l6ZUNvbmZpZy5uYW1lLFxuICAgICAgICBmaWxlbmFtZTogaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMsXG4gICAgICAgIGZpbGVzaXplOiBzaXplLFxuICAgICAgICBoZWlnaHQ6XG4gICAgICAgICAgZmlsZUlzQW5pbWF0ZWRUeXBlICYmIG9yaWdpbmFsSW1hZ2VNZXRhLnBhZ2VzID8gaGVpZ2h0IC8gb3JpZ2luYWxJbWFnZU1ldGEucGFnZXMgOiBoZWlnaHQsXG4gICAgICAgIG1pbWVUeXBlOiBtaW1lSW5mbz8ubWltZSB8fCBtaW1lVHlwZSxcbiAgICAgICAgc2l6ZXNUb1NhdmU6IFt7IGJ1ZmZlcjogYnVmZmVyRGF0YSwgcGF0aDogaW1hZ2VQYXRoIH1dLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0pXG4gICAgfSksXG4gIClcblxuICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoXG4gICAgKGFjYywgcmVzdWx0KSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKGFjYy5zaXplRGF0YSwgcmVzdWx0LnNpemVEYXRhKVxuICAgICAgYWNjLnNpemVzVG9TYXZlLnB1c2goLi4ucmVzdWx0LnNpemVzVG9TYXZlKVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sXG4gICAgeyAuLi5kZWZhdWx0UmVzdWx0IH0sXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJyZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzIiwiZ2V0U2FuaXRpemVkSW1hZ2VEYXRhIiwic291cmNlSW1hZ2UiLCJleHRlbnNpb24iLCJzcGxpdCIsInBvcCIsIm5hbWUiLCJzYW5pdGl6ZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZXh0IiwiY3JlYXRlSW1hZ2VOYW1lIiwiaGVpZ2h0Iiwib3V0cHV0SW1hZ2VOYW1lIiwid2lkdGgiLCJjcmVhdGVSZXN1bHQiLCJmaWxlbmFtZSIsImZpbGVzaXplIiwibWltZVR5cGUiLCJzaXplc1RvU2F2ZSIsInNpemVEYXRhIiwiZ2V0SW1hZ2VSZXNpemVBY3Rpb24iLCJkaW1lbnNpb25zIiwib3JpZ2luYWxJbWFnZSIsImhhc0ZvY2FsUG9pbnQiLCJpbWFnZVJlc2l6ZUNvbmZpZyIsImZpdCIsInRhcmdldEhlaWdodCIsInRhcmdldFdpZHRoIiwid2l0aG91dEVubGFyZ2VtZW50Iiwid2l0aG91dFJlZHVjdGlvbiIsIm9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYQW5kWSIsInVuZGVmaW5lZCIsIm9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYT3JZIiwiaXNOdW1iZXIiLCJ0YXJnZXRBc3BlY3RSYXRpbyIsIm9yaWdpbmFsQXNwZWN0UmF0aW8iLCJhcHBseVBheWxvYWRBZGp1c3RtZW50cyIsIm9yaWdpbmFsIiwic2tpcEVubGFyZ2VtZW50Iiwic2tpcFJlZHVjdGlvbiIsInNhbml0aXplUmVzaXplQ29uZmlnIiwicmVzaXplQ29uZmlnIiwicG9zaXRpb24iLCJleHRyYWN0SGVpZ2h0RnJvbUltYWdlIiwic2hhcnBNZXRhZGF0YSIsInBhZ2VzIiwiY29uZmlnIiwiZmlsZSIsInJlcSIsInNhdmVkRmlsZW5hbWUiLCJzdGF0aWNQYXRoIiwidXBsb2FkRWRpdHMiLCJ3aXRoTWV0YWRhdGEiLCJmb2NhbFBvaW50IiwiZm9jYWxQb2ludEVuYWJsZWQiLCJpbWFnZVNpemVzIiwidXBsb2FkIiwiaW5jb21pbmdGb2NhbFBvaW50IiwieCIsIk1hdGgiLCJyb3VuZCIsInkiLCJkZWZhdWx0UmVzdWx0IiwiZmlsZUlzQW5pbWF0ZWRUeXBlIiwiaW5jbHVkZXMiLCJtaW1ldHlwZSIsInNoYXJwT3B0aW9ucyIsImFuaW1hdGVkIiwic2hhcnBCYXNlIiwic2hhcnAiLCJ0ZW1wRmlsZVBhdGgiLCJkYXRhIiwicm90YXRlIiwib3JpZ2luYWxJbWFnZU1ldGEiLCJtZXRhZGF0YSIsInJlc2l6ZUltYWdlTWV0YSIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicmVzaXplQWN0aW9uIiwiQm9vbGVhbiIsImltYWdlVG9SZXNpemUiLCJjbG9uZSIsInJlc2l6ZWQiLCJyZXNpemVIZWlnaHQiLCJyZXNpemVXaWR0aCIsInJlc2l6ZUFzcGVjdFJhdGlvIiwicHJpb3JpdGl6ZUhlaWdodCIsInJlc2l6ZSIsIm1ldGFkYXRhQXBwZW5kZWRGaWxlIiwib3B0aW9uYWxseUFwcGVuZE1ldGFkYXRhIiwic2hhcnBGaWxlIiwiaW5mbyIsInRvQnVmZmVyIiwicmVzb2x2ZVdpdGhPYmplY3QiLCJoYWxmUmVzaXplWCIsInhGb2NhbENlbnRlciIsImNhbGN1bGF0ZWRSaWdodFBpeGVsQm91bmQiLCJsZWZ0Qm91bmQiLCJoYWxmUmVzaXplWSIsInlGb2NhbENlbnRlciIsImNhbGN1bGF0ZWRCb3R0b21QaXhlbEJvdW5kIiwidG9wQm91bmQiLCJleHRyYWN0IiwibGVmdCIsImZsb29yIiwidG9wIiwiZm9ybWF0T3B0aW9ucyIsInRvRm9ybWF0IiwiZm9ybWF0Iiwib3B0aW9ucyIsInRyaW1PcHRpb25zIiwidHJpbSIsImJ1ZmZlckRhdGEiLCJidWZmZXJJbmZvIiwic2FuaXRpemVkSW1hZ2UiLCJwYXlsb2FkVXBsb2FkU2l6ZXMiLCJtaW1lSW5mbyIsImZyb21CdWZmZXIiLCJpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyIsImltYWdlUGF0aCIsImZpbGVFeGlzdHMiLCJmcyIsInVubGlua1N5bmMiLCJzaXplIiwibWltZSIsImJ1ZmZlciIsInBhdGgiLCJyZWR1Y2UiLCJhY2MiLCJyZXN1bHQiLCJPYmplY3QiLCJhc3NpZ24iLCJwdXNoIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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