"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _getTranslation = require("../../../../../../../../utilities/getTranslation");
const _useIntersect = /*#__PURE__*/ _interop_require_default(require("../../../../../../../hooks/useIntersect"));
const _useTitle = require("../../../../../../../hooks/useTitle");
const _Config = require("../../../../../../utilities/Config");
const _RelationshipProvider = require("../../../RelationshipProvider");
const _File = /*#__PURE__*/ _interop_require_default(require("../File"));
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'relationship-cell';
const totalToShow = 3;
const RelationshipCell = (props)=>{
    const { data: cellData, field } = props;
    const config = (0, _Config.useConfig)();
    const { collections, routes } = config;
    const [intersectionRef, entry] = (0, _useIntersect.default)();
    const [values, setValues] = (0, _react.useState)([]);
    const { documents, getRelationships } = (0, _RelationshipProvider.useListRelationships)();
    const [hasRequested, setHasRequested] = (0, _react.useState)(false);
    const { i18n, t } = (0, _reacti18next.useTranslation)('general');
    const isAboveViewport = entry?.boundingClientRect?.top < window.innerHeight;
    (0, _react.useEffect)(()=>{
        if (cellData && isAboveViewport && !hasRequested) {
            const formattedValues = [];
            const arrayCellData = Array.isArray(cellData) ? cellData : [
                cellData
            ];
            arrayCellData.slice(0, arrayCellData.length < totalToShow ? arrayCellData.length : totalToShow).forEach((cell)=>{
                if (typeof cell === 'object' && 'relationTo' in cell && 'value' in cell) {
                    formattedValues.push(cell);
                }
                if ((typeof cell === 'number' || typeof cell === 'string') && 'relationTo' in field && typeof field.relationTo === 'string') {
                    formattedValues.push({
                        relationTo: field.relationTo,
                        value: cell
                    });
                }
            });
            getRelationships(formattedValues);
            setHasRequested(true);
            setValues(formattedValues);
        }
    }, [
        cellData,
        field,
        collections,
        isAboveViewport,
        routes.api,
        hasRequested,
        getRelationships
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: baseClass,
        ref: intersectionRef
    }, values.map(({ relationTo, value }, i)=>{
        const document = documents[relationTo][value];
        const relatedCollection = collections.find(({ slug })=>slug === relationTo);
        const label = (0, _useTitle.formatUseAsTitle)({
            collection: relatedCollection,
            config,
            doc: document === false ? null : document,
            i18n
        });
        let fileField = null;
        if (field.type === 'upload') {
            const relatedCollectionPreview = !!relatedCollection.upload.displayPreview;
            const fieldPreview = field.displayPreview;
            const previewAllowed = fieldPreview || relatedCollectionPreview && fieldPreview !== false;
            if (previewAllowed && document) {
                fileField = /*#__PURE__*/ _react.default.createElement(_File.default, {
                    collection: relatedCollection,
                    data: label,
                    field: field,
                    rowData: document
                });
            }
        }
        return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, {
            key: i
        }, document === false && `${t('untitled')} - ID: ${value}`, document === null && `${t('loading')}...`, document && (fileField || label || `${t('untitled')} - ID: ${value}`), values.length > i + 1 && ', ');
    }), Array.isArray(cellData) && cellData.length > totalToShow && t('fields:itemsAndMore', {
        count: cellData.length - totalToShow,
        items: ''
    }), values.length === 0 && t('noLabel', {
        label: (0, _getTranslation.getTranslation)(field?.label || '', i18n)
    }));
};
const _default = RelationshipCell;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL3ZpZXdzL2NvbGxlY3Rpb25zL0xpc3QvQ2VsbC9maWVsZC10eXBlcy9SZWxhdGlvbnNoaXAvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5cbmltcG9ydCB0eXBlIHsgUmVsYXRpb25zaGlwRmllbGQsIFVwbG9hZEZpZWxkIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZXhwb3J0cy90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2VsbENvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdHlwZXMnXG5cbmltcG9ydCB7IGdldFRyYW5zbGF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vdXRpbGl0aWVzL2dldFRyYW5zbGF0aW9uJ1xuaW1wb3J0IHVzZUludGVyc2VjdCBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9ob29rcy91c2VJbnRlcnNlY3QnXG5pbXBvcnQgeyBmb3JtYXRVc2VBc1RpdGxlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9va3MvdXNlVGl0bGUnXG5pbXBvcnQgeyB1c2VDb25maWcgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi91dGlsaXRpZXMvQ29uZmlnJ1xuaW1wb3J0IHsgdXNlTGlzdFJlbGF0aW9uc2hpcHMgfSBmcm9tICcuLi8uLi8uLi9SZWxhdGlvbnNoaXBQcm92aWRlcidcbmltcG9ydCBGaWxlIGZyb20gJy4uL0ZpbGUnXG5pbXBvcnQgJy4vaW5kZXguc2NzcydcblxudHlwZSBWYWx1ZSA9IHsgcmVsYXRpb25Ubzogc3RyaW5nOyB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIH1cbmNvbnN0IGJhc2VDbGFzcyA9ICdyZWxhdGlvbnNoaXAtY2VsbCdcbmNvbnN0IHRvdGFsVG9TaG93ID0gM1xuXG5jb25zdCBSZWxhdGlvbnNoaXBDZWxsOiBSZWFjdC5GQzxDZWxsQ29tcG9uZW50UHJvcHM8UmVsYXRpb25zaGlwRmllbGQgfCBVcGxvYWRGaWVsZD4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgZGF0YTogY2VsbERhdGEsIGZpZWxkIH0gPSBwcm9wc1xuICBjb25zdCBjb25maWcgPSB1c2VDb25maWcoKVxuICBjb25zdCB7IGNvbGxlY3Rpb25zLCByb3V0ZXMgfSA9IGNvbmZpZ1xuICBjb25zdCBbaW50ZXJzZWN0aW9uUmVmLCBlbnRyeV0gPSB1c2VJbnRlcnNlY3QoKVxuICBjb25zdCBbdmFsdWVzLCBzZXRWYWx1ZXNdID0gdXNlU3RhdGU8VmFsdWVbXT4oW10pXG4gIGNvbnN0IHsgZG9jdW1lbnRzLCBnZXRSZWxhdGlvbnNoaXBzIH0gPSB1c2VMaXN0UmVsYXRpb25zaGlwcygpXG4gIGNvbnN0IFtoYXNSZXF1ZXN0ZWQsIHNldEhhc1JlcXVlc3RlZF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgeyBpMThuLCB0IH0gPSB1c2VUcmFuc2xhdGlvbignZ2VuZXJhbCcpXG5cbiAgY29uc3QgaXNBYm92ZVZpZXdwb3J0ID0gZW50cnk/LmJvdW5kaW5nQ2xpZW50UmVjdD8udG9wIDwgd2luZG93LmlubmVySGVpZ2h0XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2VsbERhdGEgJiYgaXNBYm92ZVZpZXdwb3J0ICYmICFoYXNSZXF1ZXN0ZWQpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlczogVmFsdWVbXSA9IFtdXG5cbiAgICAgIGNvbnN0IGFycmF5Q2VsbERhdGEgPSBBcnJheS5pc0FycmF5KGNlbGxEYXRhKSA/IGNlbGxEYXRhIDogW2NlbGxEYXRhXVxuICAgICAgYXJyYXlDZWxsRGF0YVxuICAgICAgICAuc2xpY2UoMCwgYXJyYXlDZWxsRGF0YS5sZW5ndGggPCB0b3RhbFRvU2hvdyA/IGFycmF5Q2VsbERhdGEubGVuZ3RoIDogdG90YWxUb1Nob3cpXG4gICAgICAgIC5mb3JFYWNoKChjZWxsKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjZWxsID09PSAnb2JqZWN0JyAmJiAncmVsYXRpb25UbycgaW4gY2VsbCAmJiAndmFsdWUnIGluIGNlbGwpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlcy5wdXNoKGNlbGwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICh0eXBlb2YgY2VsbCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNlbGwgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgJ3JlbGF0aW9uVG8nIGluIGZpZWxkICYmXG4gICAgICAgICAgICB0eXBlb2YgZmllbGQucmVsYXRpb25UbyA9PT0gJ3N0cmluZydcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcmVsYXRpb25UbzogZmllbGQucmVsYXRpb25UbyxcbiAgICAgICAgICAgICAgdmFsdWU6IGNlbGwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIGdldFJlbGF0aW9uc2hpcHMoZm9ybWF0dGVkVmFsdWVzKVxuICAgICAgc2V0SGFzUmVxdWVzdGVkKHRydWUpXG4gICAgICBzZXRWYWx1ZXMoZm9ybWF0dGVkVmFsdWVzKVxuICAgIH1cbiAgfSwgW2NlbGxEYXRhLCBmaWVsZCwgY29sbGVjdGlvbnMsIGlzQWJvdmVWaWV3cG9ydCwgcm91dGVzLmFwaSwgaGFzUmVxdWVzdGVkLCBnZXRSZWxhdGlvbnNoaXBzXSlcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtiYXNlQ2xhc3N9IHJlZj17aW50ZXJzZWN0aW9uUmVmfT5cbiAgICAgIHt2YWx1ZXMubWFwKCh7IHJlbGF0aW9uVG8sIHZhbHVlIH0sIGkpID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBkb2N1bWVudHNbcmVsYXRpb25Ub11bdmFsdWVdXG4gICAgICAgIGNvbnN0IHJlbGF0ZWRDb2xsZWN0aW9uID0gY29sbGVjdGlvbnMuZmluZCgoeyBzbHVnIH0pID0+IHNsdWcgPT09IHJlbGF0aW9uVG8pXG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSBmb3JtYXRVc2VBc1RpdGxlKHtcbiAgICAgICAgICBjb2xsZWN0aW9uOiByZWxhdGVkQ29sbGVjdGlvbixcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgZG9jOiBkb2N1bWVudCA9PT0gZmFsc2UgPyBudWxsIDogZG9jdW1lbnQsXG4gICAgICAgICAgaTE4bixcbiAgICAgICAgfSlcblxuICAgICAgICBsZXQgZmlsZUZpZWxkID0gbnVsbFxuICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ3VwbG9hZCcpIHtcbiAgICAgICAgICBjb25zdCByZWxhdGVkQ29sbGVjdGlvblByZXZpZXcgPSAhIXJlbGF0ZWRDb2xsZWN0aW9uLnVwbG9hZC5kaXNwbGF5UHJldmlld1xuICAgICAgICAgIGNvbnN0IGZpZWxkUHJldmlldyA9IGZpZWxkLmRpc3BsYXlQcmV2aWV3XG4gICAgICAgICAgY29uc3QgcHJldmlld0FsbG93ZWQgPVxuICAgICAgICAgICAgZmllbGRQcmV2aWV3IHx8IChyZWxhdGVkQ29sbGVjdGlvblByZXZpZXcgJiYgZmllbGRQcmV2aWV3ICE9PSBmYWxzZSlcbiAgICAgICAgICBpZiAocHJldmlld0FsbG93ZWQgJiYgZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGZpbGVGaWVsZCA9IChcbiAgICAgICAgICAgICAgPEZpbGUgY29sbGVjdGlvbj17cmVsYXRlZENvbGxlY3Rpb259IGRhdGE9e2xhYmVsfSBmaWVsZD17ZmllbGR9IHJvd0RhdGE9e2RvY3VtZW50fSAvPlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPFJlYWN0LkZyYWdtZW50IGtleT17aX0+XG4gICAgICAgICAgICB7ZG9jdW1lbnQgPT09IGZhbHNlICYmIGAke3QoJ3VudGl0bGVkJyl9IC0gSUQ6ICR7dmFsdWV9YH1cbiAgICAgICAgICAgIHtkb2N1bWVudCA9PT0gbnVsbCAmJiBgJHt0KCdsb2FkaW5nJyl9Li4uYH1cbiAgICAgICAgICAgIHtkb2N1bWVudCAmJiAoZmlsZUZpZWxkIHx8IGxhYmVsIHx8IGAke3QoJ3VudGl0bGVkJyl9IC0gSUQ6ICR7dmFsdWV9YCl9XG4gICAgICAgICAgICB7dmFsdWVzLmxlbmd0aCA+IGkgKyAxICYmICcsICd9XG4gICAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICAgKVxuICAgICAgfSl9XG4gICAgICB7QXJyYXkuaXNBcnJheShjZWxsRGF0YSkgJiZcbiAgICAgICAgY2VsbERhdGEubGVuZ3RoID4gdG90YWxUb1Nob3cgJiZcbiAgICAgICAgdCgnZmllbGRzOml0ZW1zQW5kTW9yZScsIHsgY291bnQ6IGNlbGxEYXRhLmxlbmd0aCAtIHRvdGFsVG9TaG93LCBpdGVtczogJycgfSl9XG4gICAgICB7dmFsdWVzLmxlbmd0aCA9PT0gMCAmJiB0KCdub0xhYmVsJywgeyBsYWJlbDogZ2V0VHJhbnNsYXRpb24oZmllbGQ/LmxhYmVsIHx8ICcnLCBpMThuKSB9KX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWxhdGlvbnNoaXBDZWxsXG4iXSwibmFtZXMiOlsiYmFzZUNsYXNzIiwidG90YWxUb1Nob3ciLCJSZWxhdGlvbnNoaXBDZWxsIiwicHJvcHMiLCJkYXRhIiwiY2VsbERhdGEiLCJmaWVsZCIsImNvbmZpZyIsInVzZUNvbmZpZyIsImNvbGxlY3Rpb25zIiwicm91dGVzIiwiaW50ZXJzZWN0aW9uUmVmIiwiZW50cnkiLCJ1c2VJbnRlcnNlY3QiLCJ2YWx1ZXMiLCJzZXRWYWx1ZXMiLCJ1c2VTdGF0ZSIsImRvY3VtZW50cyIsImdldFJlbGF0aW9uc2hpcHMiLCJ1c2VMaXN0UmVsYXRpb25zaGlwcyIsImhhc1JlcXVlc3RlZCIsInNldEhhc1JlcXVlc3RlZCIsImkxOG4iLCJ0IiwidXNlVHJhbnNsYXRpb24iLCJpc0Fib3ZlVmlld3BvcnQiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsInVzZUVmZmVjdCIsImZvcm1hdHRlZFZhbHVlcyIsImFycmF5Q2VsbERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsImxlbmd0aCIsImZvckVhY2giLCJjZWxsIiwicHVzaCIsInJlbGF0aW9uVG8iLCJ2YWx1ZSIsImFwaSIsImRpdiIsImNsYXNzTmFtZSIsInJlZiIsIm1hcCIsImkiLCJkb2N1bWVudCIsInJlbGF0ZWRDb2xsZWN0aW9uIiwiZmluZCIsInNsdWciLCJsYWJlbCIsImZvcm1hdFVzZUFzVGl0bGUiLCJjb2xsZWN0aW9uIiwiZG9jIiwiZmlsZUZpZWxkIiwidHlwZSIsInJlbGF0ZWRDb2xsZWN0aW9uUHJldmlldyIsInVwbG9hZCIsImRpc3BsYXlQcmV2aWV3IiwiZmllbGRQcmV2aWV3IiwicHJldmlld0FsbG93ZWQiLCJGaWxlIiwicm93RGF0YSIsIlJlYWN0IiwiRnJhZ21lbnQiLCJrZXkiLCJjb3VudCIsIml0ZW1zIiwiZ2V0VHJhbnNsYXRpb24iXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwibWFwcGluZ3MiOiI7Ozs7K0JBcUdBOzs7ZUFBQTs7OytEQXJHMkM7OEJBQ1o7Z0NBS0E7cUVBQ047MEJBQ1E7d0JBQ1A7c0NBQ1c7NkRBQ3BCO1FBQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR1AsTUFBTUEsWUFBWTtBQUNsQixNQUFNQyxjQUFjO0FBRXBCLE1BQU1DLG1CQUFr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