'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _ishotkey = /*#__PURE__*/ _interop_require_default(require("is-hotkey"));
const _forms = require("payload/components/forms");
const _utilities = require("payload/components/utilities");
const _utilities1 = require("payload/utilities");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _slate = require("slate");
const _slatehistory = require("slate-history");
const _slatereact = require("slate-react");
const _defaultValue = require("../data/defaultValue");
const _validation = require("../data/validation");
const _elements = /*#__PURE__*/ _interop_require_default(require("./elements"));
const _listTypes = /*#__PURE__*/ _interop_require_default(require("./elements/listTypes"));
const _enablePlugins = /*#__PURE__*/ _interop_require_default(require("./enablePlugins"));
const _hotkeys = /*#__PURE__*/ _interop_require_default(require("./hotkeys"));
require("./index.scss");
const _leaves = /*#__PURE__*/ _interop_require_default(require("./leaves"));
const _toggle = /*#__PURE__*/ _interop_require_default(require("./leaves/toggle"));
const _mergeCustomFunctions = /*#__PURE__*/ _interop_require_default(require("./mergeCustomFunctions"));
const _withEnterBreakOut = /*#__PURE__*/ _interop_require_default(require("./plugins/withEnterBreakOut"));
const _withHTML = /*#__PURE__*/ _interop_require_default(require("./plugins/withHTML"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const defaultElements = [
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'ul',
    'ol',
    'indent',
    'link',
    'relationship',
    'upload'
];
const defaultLeaves = [
    'bold',
    'italic',
    'underline',
    'strikethrough',
    'code'
];
const baseClass = 'rich-text';
const RichText = (props)=>{
    const { name, admin: { className, components: { Error, Label } = {}, condition, description, hideGutter, placeholder, readOnly, style, width } = {
        className: undefined,
        components: {},
        condition: undefined,
        description: undefined,
        hideGutter: undefined,
        placeholder: undefined,
        readOnly: undefined,
        style: undefined,
        width: undefined
    }, admin, defaultValue: defaultValueFromProps, label, path: pathFromProps, required, validate = _validation.richTextValidate } = props;
    const elements = admin?.elements || defaultElements;
    const leaves = admin?.leaves || defaultLeaves;
    const path = pathFromProps || name;
    const { i18n } = (0, _reacti18next.useTranslation)();
    const [loaded, setLoaded] = (0, _react.useState)(false);
    const [enabledElements, setEnabledElements] = (0, _react.useState)({});
    const [enabledLeaves, setEnabledLeaves] = (0, _react.useState)({});
    const editorRef = (0, _react.useRef)(null);
    const toolbarRef = (0, _react.useRef)(null);
    const drawerDepth = (0, _utilities.useEditDepth)();
    const drawerIsOpen = drawerDepth > 1;
    const renderElement = (0, _react.useCallback)(({ attributes, children, element })=>{
        const matchedElement = enabledElements[element.type];
        const Element = matchedElement?.Element;
        let attr = {
            ...attributes
        };
        // this converts text alignment to margin when dealing with void elements
        if (element.textAlign) {
            if (element.type === 'relationship' || element.type === 'upload') {
                switch(element.textAlign){
                    case 'left':
                        attr = {
                            ...attr,
                            style: {
                                marginRight: 'auto'
                            }
                        };
                        break;
                    case 'right':
                        attr = {
                            ...attr,
                            style: {
                                marginLeft: 'auto'
                            }
                        };
                        break;
                    case 'center':
                        attr = {
                            ...attr,
                            style: {
                                marginLeft: 'auto',
                                marginRight: 'auto'
                            }
                        };
                        break;
                    default:
                        attr = {
                            ...attr,
                            style: {
                                textAlign: element.textAlign
                            }
                        };
                        break;
                }
            } else if (element.type === 'li') {
                switch(element.textAlign){
                    case 'right':
                        attr = {
                            ...attr,
                            style: {
                                listStylePosition: 'inside',
                                textAlign: 'right'
                            }
                        };
                        break;
                    case 'center':
                        attr = {
                            ...attr,
                            style: {
                                listStylePosition: 'inside',
                                textAlign: 'center'
                            }
                        };
                        break;
                    case 'left':
                    default:
                        attr = {
                            ...attr,
                            style: {
                                listStylePosition: 'outside',
                                textAlign: 'left'
                            }
                        };
                        break;
                }
            } else {
                attr = {
                    ...attr,
                    style: {
                        textAlign: element.textAlign
                    }
                };
            }
        }
        if (Element) {
            const el = /*#__PURE__*/ _react.default.createElement(Element, {
                attributes: attr,
                editorRef: editorRef,
                element: element,
                fieldProps: props,
                path: path
            }, children);
            return el;
        }
        return /*#__PURE__*/ _react.default.createElement("div", attr, children);
    }, [
        enabledElements,
        path,
        props
    ]);
    const renderLeaf = (0, _react.useCallback)(({ attributes, children, leaf })=>{
        const matchedLeaves = Object.entries(enabledLeaves).filter(([leafName])=>leaf[leafName]);
        if (matchedLeaves.length > 0) {
            return matchedLeaves.reduce((result, [leafName], i)=>{
                if (enabledLeaves[leafName]?.Leaf) {
                    const Leaf = enabledLeaves[leafName]?.Leaf;
                    return /*#__PURE__*/ _react.default.createElement(Leaf, {
                        editorRef: editorRef,
                        fieldProps: props,
                        key: i,
                        leaf: leaf,
                        path: path
                    }, result);
                }
                return result;
            }, /*#__PURE__*/ _react.default.createElement("span", attributes, children));
        }
        return /*#__PURE__*/ _react.default.createElement("span", attributes, children);
    }, [
        enabledLeaves,
        path,
        props
    ]);
    const memoizedValidate = (0, _react.useCallback)((value, validationOptions)=>{
        return validate(value, {
            ...validationOptions,
            required
        });
    }, [
        validate,
        required
    ]);
    const fieldType = (0, _forms.useField)({
        condition,
        path,
        validate: memoizedValidate
    });
    const { errorMessage, initialValue, setValue, showError, value } = fieldType;
    const classes = [
        baseClass,
        'field-type',
        className,
        showError && 'error',
        readOnly && `${baseClass}--read-only`,
        !hideGutter && `${baseClass}--gutter`
    ].filter(Boolean).join(' ');
    const editor = (0, _react.useMemo)(()=>{
        let CreatedEditor = (0, _withEnterBreakOut.default)((0, _slatehistory.withHistory)((0, _slatereact.withReact)((0, _slate.createEditor)())));
        CreatedEditor = (0, _withHTML.default)(CreatedEditor);
        CreatedEditor = (0, _enablePlugins.default)(CreatedEditor, elements);
        CreatedEditor = (0, _enablePlugins.default)(CreatedEditor, leaves);
        return CreatedEditor;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        elements,
        leaves,
        path
    ]);
    // All slate changes fire the onChange event
    // including selection changes
    // so we will filter the set_selection operations out
    // and only fire setValue when onChange is because of value
    const handleChange = (0, _react.useCallback)((val)=>{
        const ops = editor.operations.filter((o)=>{
            if (o) {
                return o.type !== 'set_selection';
            }
            return false;
        });
        if (ops && Array.isArray(ops) && ops.length > 0) {
            if (!readOnly && val !== _defaultValue.defaultRichTextValue && val !== value) {
                setValue(val);
            }
        }
    }, [
        editor.operations,
        readOnly,
        setValue,
        value
    ]);
    (0, _react.useEffect)(()=>{
        if (!loaded) {
            const mergedElements = (0, _mergeCustomFunctions.default)(elements, _elements.default);
            const mergedLeaves = (0, _mergeCustomFunctions.default)(leaves, _leaves.default);
            setEnabledElements(mergedElements);
            setEnabledLeaves(mergedLeaves);
            setLoaded(true);
        }
    }, [
        loaded,
        elements,
        leaves
    ]);
    (0, _react.useEffect)(()=>{
        function setClickableState(clickState) {
            const selectors = 'button, a, [role="button"]';
            const toolbarButtons = toolbarRef.current?.querySelectorAll(selectors);
            (toolbarButtons || []).forEach((child)=>{
                const isButton = child.tagName === 'BUTTON';
                const isDisabling = clickState === 'disabled';
                child.setAttribute('tabIndex', isDisabling ? '-1' : '0');
                if (isButton) child.setAttribute('disabled', isDisabling ? 'disabled' : null);
            });
        }
        if (loaded && readOnly) {
            setClickableState('disabled');
        }
        return ()=>{
            if (loaded && readOnly) {
                setClickableState('enabled');
            }
        };
    }, [
        loaded,
        readOnly
    ]);
    // useEffect(() => {
    //   // If there is a change to the initial value, we need to reset Slate history
    //   // and clear selection because the old selection may no longer be valid
    //   // as returned JSON may be modified in hooks and have a different shape
    //   if (editor.selection) {
    //     console.log('deselecting');
    //     ReactEditor.deselect(editor);
    //   }
    // }, [path, editor]);
    if (!loaded) {
        return null;
    }
    let valueToRender = value;
    if (typeof valueToRender === 'string') {
        try {
            const parsedJSON = JSON.parse(valueToRender);
            valueToRender = parsedJSON;
        } catch (err) {
            valueToRender = null;
        }
    }
    if (!valueToRender) valueToRender = defaultValueFromProps || _defaultValue.defaultRichTextValue;
    const ErrorComp = Error || _forms.Error;
    const LabelComp = Label || _forms.Label;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: classes,
        style: {
            ...style,
            width
        }
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__wrap`
    }, /*#__PURE__*/ _react.default.createElement(ErrorComp, {
        message: errorMessage,
        showError: showError
    }), /*#__PURE__*/ _react.default.createElement(LabelComp, {
        htmlFor: `field-${path.replace(/\./g, '__')}`,
        label: label,
        required: required
    }), /*#__PURE__*/ _react.default.createElement(_slatereact.Slate, {
        editor: editor,
        key: JSON.stringify({
            initialValue,
            path
        }),
        onChange: handleChange,
        value: valueToRender
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__wrapper`
    }, elements?.length + leaves?.length > 0 && /*#__PURE__*/ _react.default.createElement("div", {
        className: [
            `${baseClass}__toolbar`,
            drawerIsOpen && `${baseClass}__drawerIsOpen`
        ].filter(Boolean).join(' '),
        ref: toolbarRef
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__toolbar-wrap`
    }, elements.map((element, i)=>{
        let elementName;
        if (typeof element === 'object' && element?.name) elementName = element.name;
        if (typeof element === 'string') elementName = element;
        const elementType = enabledElements[elementName];
        const Button = elementType?.Button;
        if (Button) {
            return /*#__PURE__*/ _react.default.createElement(Button, {
                fieldProps: props,
                key: i,
                path: path
            });
        }
        return null;
    }), leaves.map((leaf, i)=>{
        let leafName;
        if (typeof leaf === 'object' && leaf?.name) leafName = leaf.name;
        if (typeof leaf === 'string') leafName = leaf;
        const leafType = enabledLeaves[leafName];
        const Button = leafType?.Button;
        if (Button) {
            return /*#__PURE__*/ _react.default.createElement(Button, {
                fieldProps: props,
                key: i,
                path: path
            });
        }
        return null;
    }))), /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__editor`,
        ref: editorRef
    }, /*#__PURE__*/ _react.default.createElement(_slatereact.Editable, {
        className: `${baseClass}__input`,
        id: `field-${path.replace(/\./g, '__')}`,
        onKeyDown: (event)=>{
            if (event.key === 'Enter') {
                if (event.shiftKey) {
                    event.preventDefault();
                    editor.insertText('\n');
                } else {
                    const selectedElement = _slate.Node.descendant(editor, editor.selection.anchor.path.slice(0, -1));
                    if (_slate.Element.isElement(selectedElement)) {
                        // Allow hard enter to "break out" of certain elements
                        if (editor.shouldBreakOutOnEnter(selectedElement)) {
                            event.preventDefault();
                            const selectedLeaf = _slate.Node.descendant(editor, editor.selection.anchor.path);
                            if (_slate.Text.isText(selectedLeaf) && String(selectedLeaf.text).length === editor.selection.anchor.offset) {
                                _slate.Transforms.insertNodes(editor, {
                                    children: [
                                        {
                                            text: ''
                                        }
                                    ]
                                });
                            } else {
                                _slate.Transforms.splitNodes(editor);
                                _slate.Transforms.setNodes(editor, {});
                            }
                        }
                    }
                }
            }
            if (event.key === 'Backspace') {
                const selectedElement = _slate.Node.descendant(editor, editor.selection.anchor.path.slice(0, -1));
                if (_slate.Element.isElement(selectedElement) && selectedElement.type === 'li') {
                    const selectedLeaf = _slate.Node.descendant(editor, editor.selection.anchor.path);
                    if (_slate.Text.isText(selectedLeaf) && String(selectedLeaf.text).length === 0) {
                        event.preventDefault();
                        _slate.Transforms.unwrapNodes(editor, {
                            match: (n)=>_slate.Element.isElement(n) && _listTypes.default.includes(n.type),
                            mode: 'lowest',
                            split: true
                        });
                        _slate.Transforms.setNodes(editor, {
                            type: undefined
                        });
                    }
                } else if (editor.isVoid(selectedElement)) {
                    _slate.Transforms.removeNodes(editor);
                }
            }
            Object.keys(_hotkeys.default).forEach((hotkey)=>{
                if ((0, _ishotkey.default)(hotkey, event)) {
                    event.preventDefault();
                    const mark = _hotkeys.default[hotkey];
                    (0, _toggle.default)(editor, mark);
                }
            });
        },
        placeholder: (0, _utilities1.getTranslation)(placeholder, i18n),
        readOnly: readOnly,
        renderElement: renderElement,
        renderLeaf: renderLeaf,
        spellCheck: true
    })))), /*#__PURE__*/ _react.default.createElement(_forms.FieldDescription, {
        description: description,
        path: path,
        value: value
    })));
};
const _default = (0, _forms.withCondition)(RichText);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9maWVsZC9SaWNoVGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgQmFzZUVkaXRvciwgQmFzZU9wZXJhdGlvbiB9IGZyb20gJ3NsYXRlJ1xuaW1wb3J0IHR5cGUgeyBIaXN0b3J5RWRpdG9yIH0gZnJvbSAnc2xhdGUtaGlzdG9yeSdcbmltcG9ydCB0eXBlIHsgUmVhY3RFZGl0b3IgfSBmcm9tICdzbGF0ZS1yZWFjdCdcblxuaW1wb3J0IGlzSG90a2V5IGZyb20gJ2lzLWhvdGtleSdcbmltcG9ydCB7XG4gIEVycm9yIGFzIERlZmF1bHRFcnJvcixcbiAgTGFiZWwgYXMgRGVmYXVsdExhYmVsLFxuICBGaWVsZERlc2NyaXB0aW9uLFxuICB1c2VGaWVsZCxcbiAgd2l0aENvbmRpdGlvbixcbn0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL2Zvcm1zJ1xuaW1wb3J0IHsgdXNlRWRpdERlcHRoIH0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL3V0aWxpdGllcydcbmltcG9ydCB7IGdldFRyYW5zbGF0aW9uIH0gZnJvbSAncGF5bG9hZC91dGlsaXRpZXMnXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlVHJhbnNsYXRpb24gfSBmcm9tICdyZWFjdC1pMThuZXh0J1xuaW1wb3J0IHsgTm9kZSwgRWxlbWVudCBhcyBTbGF0ZUVsZW1lbnQsIFRleHQsIFRyYW5zZm9ybXMsIGNyZWF0ZUVkaXRvciB9IGZyb20gJ3NsYXRlJ1xuaW1wb3J0IHsgd2l0aEhpc3RvcnkgfSBmcm9tICdzbGF0ZS1oaXN0b3J5J1xuaW1wb3J0IHsgRWRpdGFibGUsIFNsYXRlLCB3aXRoUmVhY3QgfSBmcm9tICdzbGF0ZS1yZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBFbGVtZW50Tm9kZSwgRmllbGRQcm9wcywgUmljaFRleHRFbGVtZW50LCBSaWNoVGV4dExlYWYsIFRleHROb2RlIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmltcG9ydCB7IGRlZmF1bHRSaWNoVGV4dFZhbHVlIH0gZnJvbSAnLi4vZGF0YS9kZWZhdWx0VmFsdWUnXG5pbXBvcnQgeyByaWNoVGV4dFZhbGlkYXRlIH0gZnJvbSAnLi4vZGF0YS92YWxpZGF0aW9uJ1xuaW1wb3J0IGVsZW1lbnRUeXBlcyBmcm9tICcuL2VsZW1lbnRzJ1xuaW1wb3J0IGxpc3RUeXBlcyBmcm9tICcuL2VsZW1lbnRzL2xpc3RUeXBlcydcbmltcG9ydCBlbmFibGVQbHVnaW5zIGZyb20gJy4vZW5hYmxlUGx1Z2lucydcbmltcG9ydCBob3RrZXlzIGZyb20gJy4vaG90a2V5cydcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuaW1wb3J0IGxlYWZUeXBlcyBmcm9tICcuL2xlYXZlcydcbmltcG9ydCB0b2dnbGVMZWFmIGZyb20gJy4vbGVhdmVzL3RvZ2dsZSdcbmltcG9ydCBtZXJnZUN1c3RvbUZ1bmN0aW9ucyBmcm9tICcuL21lcmdlQ3VzdG9tRnVuY3Rpb25zJ1xuaW1wb3J0IHdpdGhFbnRlckJyZWFrT3V0IGZyb20gJy4vcGx1Z2lucy93aXRoRW50ZXJCcmVha091dCdcbmltcG9ydCB3aXRoSFRNTCBmcm9tICcuL3BsdWdpbnMvd2l0aEhUTUwnXG5cbmNvbnN0IGRlZmF1bHRFbGVtZW50czogUmljaFRleHRFbGVtZW50W10gPSBbXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICd1bCcsXG4gICdvbCcsXG4gICdpbmRlbnQnLFxuICAnbGluaycsXG4gICdyZWxhdGlvbnNoaXAnLFxuICAndXBsb2FkJyxcbl1cbmNvbnN0IGRlZmF1bHRMZWF2ZXM6IFJpY2hUZXh0TGVhZltdID0gWydib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnc3RyaWtldGhyb3VnaCcsICdjb2RlJ11cblxuY29uc3QgYmFzZUNsYXNzID0gJ3JpY2gtdGV4dCdcblxuZGVjbGFyZSBtb2R1bGUgJ3NsYXRlJyB7XG4gIGludGVyZmFjZSBDdXN0b21UeXBlcyB7XG4gICAgRWRpdG9yOiBCYXNlRWRpdG9yICYgUmVhY3RFZGl0b3IgJiBIaXN0b3J5RWRpdG9yXG4gICAgRWxlbWVudDogRWxlbWVudE5vZGVcbiAgICBUZXh0OiBUZXh0Tm9kZVxuICB9XG59XG5cbmNvbnN0IFJpY2hUZXh0OiBSZWFjdC5GQzxGaWVsZFByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgbmFtZSxcbiAgICBhZG1pbjoge1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgY29tcG9uZW50czogeyBFcnJvciwgTGFiZWwgfSA9IHt9LFxuICAgICAgY29uZGl0aW9uLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBoaWRlR3V0dGVyLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICByZWFkT25seSxcbiAgICAgIHN0eWxlLFxuICAgICAgd2lkdGgsXG4gICAgfSA9IHtcbiAgICAgIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICAgICAgY29tcG9uZW50czoge30sXG4gICAgICBjb25kaXRpb246IHVuZGVmaW5lZCxcbiAgICAgIGRlc2NyaXB0aW9uOiB1bmRlZmluZWQsXG4gICAgICBoaWRlR3V0dGVyOiB1bmRlZmluZWQsXG4gICAgICBwbGFjZWhvbGRlcjogdW5kZWZpbmVkLFxuICAgICAgcmVhZE9ubHk6IHVuZGVmaW5lZCxcbiAgICAgIHN0eWxlOiB1bmRlZmluZWQsXG4gICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgYWRtaW4sXG4gICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGcm9tUHJvcHMsXG4gICAgbGFiZWwsXG4gICAgcGF0aDogcGF0aEZyb21Qcm9wcyxcbiAgICByZXF1aXJlZCxcbiAgICB2YWxpZGF0ZSA9IHJpY2hUZXh0VmFsaWRhdGUsXG4gIH0gPSBwcm9wc1xuXG4gIGNvbnN0IGVsZW1lbnRzOiBSaWNoVGV4dEVsZW1lbnRbXSA9IGFkbWluPy5lbGVtZW50cyB8fCBkZWZhdWx0RWxlbWVudHNcbiAgY29uc3QgbGVhdmVzOiBSaWNoVGV4dExlYWZbXSA9IGFkbWluPy5sZWF2ZXMgfHwgZGVmYXVsdExlYXZlc1xuXG4gIGNvbnN0IHBhdGggPSBwYXRoRnJvbVByb3BzIHx8IG5hbWVcblxuICBjb25zdCB7IGkxOG4gfSA9IHVzZVRyYW5zbGF0aW9uKClcbiAgY29uc3QgW2xvYWRlZCwgc2V0TG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbZW5hYmxlZEVsZW1lbnRzLCBzZXRFbmFibGVkRWxlbWVudHNdID0gdXNlU3RhdGUoe30pXG4gIGNvbnN0IFtlbmFibGVkTGVhdmVzLCBzZXRFbmFibGVkTGVhdmVzXSA9IHVzZVN0YXRlKHt9KVxuICBjb25zdCBlZGl0b3JSZWYgPSB1c2VSZWYobnVsbClcbiAgY29uc3QgdG9vbGJhclJlZiA9IHVzZVJlZihudWxsKVxuXG4gIGNvbnN0IGRyYXdlckRlcHRoID0gdXNlRWRpdERlcHRoKClcbiAgY29uc3QgZHJhd2VySXNPcGVuID0gZHJhd2VyRGVwdGggPiAxXG5cbiAgY29uc3QgcmVuZGVyRWxlbWVudCA9IHVzZUNhbGxiYWNrKFxuICAgICh7IGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCBlbGVtZW50IH0pID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZWRFbGVtZW50ID0gZW5hYmxlZEVsZW1lbnRzW2VsZW1lbnQudHlwZV1cbiAgICAgIGNvbnN0IEVsZW1lbnQgPSBtYXRjaGVkRWxlbWVudD8uRWxlbWVudFxuXG4gICAgICBsZXQgYXR0ciA9IHsgLi4uYXR0cmlidXRlcyB9XG5cbiAgICAgIC8vIHRoaXMgY29udmVydHMgdGV4dCBhbGlnbm1lbnQgdG8gbWFyZ2luIHdoZW4gZGVhbGluZyB3aXRoIHZvaWQgZWxlbWVudHNcbiAgICAgIGlmIChlbGVtZW50LnRleHRBbGlnbikge1xuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAncmVsYXRpb25zaGlwJyB8fCBlbGVtZW50LnR5cGUgPT09ICd1cGxvYWQnKSB7XG4gICAgICAgICAgc3dpdGNoIChlbGVtZW50LnRleHRBbGlnbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgIGF0dHIgPSB7IC4uLmF0dHIsIHN0eWxlOiB7IG1hcmdpblJpZ2h0OiAnYXV0bycgfSB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgIGF0dHIgPSB7IC4uLmF0dHIsIHN0eWxlOiB7IG1hcmdpbkxlZnQ6ICdhdXRvJyB9IH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgIGF0dHIgPSB7IC4uLmF0dHIsIHN0eWxlOiB7IG1hcmdpbkxlZnQ6ICdhdXRvJywgbWFyZ2luUmlnaHQ6ICdhdXRvJyB9IH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGF0dHIgPSB7IC4uLmF0dHIsIHN0eWxlOiB7IHRleHRBbGlnbjogZWxlbWVudC50ZXh0QWxpZ24gfSB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ2xpJykge1xuICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC50ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgYXR0ciA9IHsgLi4uYXR0ciwgc3R5bGU6IHsgbGlzdFN0eWxlUG9zaXRpb246ICdpbnNpZGUnLCB0ZXh0QWxpZ246ICdyaWdodCcgfSB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICBhdHRyID0geyAuLi5hdHRyLCBzdHlsZTogeyBsaXN0U3R5bGVQb3NpdGlvbjogJ2luc2lkZScsIHRleHRBbGlnbjogJ2NlbnRlcicgfSB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGF0dHIgPSB7IC4uLmF0dHIsIHN0eWxlOiB7IGxpc3RTdHlsZVBvc2l0aW9uOiAnb3V0c2lkZScsIHRleHRBbGlnbjogJ2xlZnQnIH0gfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyID0geyAuLi5hdHRyLCBzdHlsZTogeyB0ZXh0QWxpZ246IGVsZW1lbnQudGV4dEFsaWduIH0gfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGVsID0gKFxuICAgICAgICAgIDxFbGVtZW50XG4gICAgICAgICAgICBhdHRyaWJ1dGVzPXthdHRyfVxuICAgICAgICAgICAgZWRpdG9yUmVmPXtlZGl0b3JSZWZ9XG4gICAgICAgICAgICBlbGVtZW50PXtlbGVtZW50fVxuICAgICAgICAgICAgZmllbGRQcm9wcz17cHJvcHN9XG4gICAgICAgICAgICBwYXRoPXtwYXRofVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L0VsZW1lbnQ+XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4gZWxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDxkaXYgey4uLmF0dHJ9PntjaGlsZHJlbn08L2Rpdj5cbiAgICB9LFxuICAgIFtlbmFibGVkRWxlbWVudHMsIHBhdGgsIHByb3BzXSxcbiAgKVxuXG4gIGNvbnN0IHJlbmRlckxlYWYgPSB1c2VDYWxsYmFjayhcbiAgICAoeyBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgbGVhZiB9KSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVkTGVhdmVzID0gT2JqZWN0LmVudHJpZXMoZW5hYmxlZExlYXZlcykuZmlsdGVyKChbbGVhZk5hbWVdKSA9PiBsZWFmW2xlYWZOYW1lXSlcblxuICAgICAgaWYgKG1hdGNoZWRMZWF2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZExlYXZlcy5yZWR1Y2UoXG4gICAgICAgICAgKHJlc3VsdCwgW2xlYWZOYW1lXSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWRMZWF2ZXNbbGVhZk5hbWVdPy5MZWFmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IExlYWYgPSBlbmFibGVkTGVhdmVzW2xlYWZOYW1lXT8uTGVhZlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxMZWFmIGVkaXRvclJlZj17ZWRpdG9yUmVmfSBmaWVsZFByb3BzPXtwcm9wc30ga2V5PXtpfSBsZWFmPXtsZWFmfSBwYXRoPXtwYXRofT5cbiAgICAgICAgICAgICAgICAgIHtyZXN1bHR9XG4gICAgICAgICAgICAgICAgPC9MZWFmPlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIDxzcGFuIHsuLi5hdHRyaWJ1dGVzfT57Y2hpbGRyZW59PC9zcGFuPixcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gPHNwYW4gey4uLmF0dHJpYnV0ZXN9PntjaGlsZHJlbn08L3NwYW4+XG4gICAgfSxcbiAgICBbZW5hYmxlZExlYXZlcywgcGF0aCwgcHJvcHNdLFxuICApXG5cbiAgY29uc3QgbWVtb2l6ZWRWYWxpZGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgICh2YWx1ZSwgdmFsaWRhdGlvbk9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgeyAuLi52YWxpZGF0aW9uT3B0aW9ucywgcmVxdWlyZWQgfSlcbiAgICB9LFxuICAgIFt2YWxpZGF0ZSwgcmVxdWlyZWRdLFxuICApXG5cbiAgY29uc3QgZmllbGRUeXBlID0gdXNlRmllbGQoe1xuICAgIGNvbmRpdGlvbixcbiAgICBwYXRoLFxuICAgIHZhbGlkYXRlOiBtZW1vaXplZFZhbGlkYXRlLFxuICB9KVxuXG4gIGNvbnN0IHsgZXJyb3JNZXNzYWdlLCBpbml0aWFsVmFsdWUsIHNldFZhbHVlLCBzaG93RXJyb3IsIHZhbHVlIH0gPSBmaWVsZFR5cGVcblxuICBjb25zdCBjbGFzc2VzID0gW1xuICAgIGJhc2VDbGFzcyxcbiAgICAnZmllbGQtdHlwZScsXG4gICAgY2xhc3NOYW1lLFxuICAgIHNob3dFcnJvciAmJiAnZXJyb3InLFxuICAgIHJlYWRPbmx5ICYmIGAke2Jhc2VDbGFzc30tLXJlYWQtb25seWAsXG4gICAgIWhpZGVHdXR0ZXIgJiYgYCR7YmFzZUNsYXNzfS0tZ3V0dGVyYCxcbiAgXVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuam9pbignICcpXG5cbiAgY29uc3QgZWRpdG9yID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IENyZWF0ZWRFZGl0b3IgPSB3aXRoRW50ZXJCcmVha091dCh3aXRoSGlzdG9yeSh3aXRoUmVhY3QoY3JlYXRlRWRpdG9yKCkpKSlcblxuICAgIENyZWF0ZWRFZGl0b3IgPSB3aXRoSFRNTChDcmVhdGVkRWRpdG9yKVxuICAgIENyZWF0ZWRFZGl0b3IgPSBlbmFibGVQbHVnaW5zKENyZWF0ZWRFZGl0b3IsIGVsZW1lbnRzKVxuICAgIENyZWF0ZWRFZGl0b3IgPSBlbmFibGVQbHVnaW5zKENyZWF0ZWRFZGl0b3IsIGxlYXZlcylcblxuICAgIHJldHVybiBDcmVhdGVkRWRpdG9yXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbZWxlbWVudHMsIGxlYXZlcywgcGF0aF0pXG5cbiAgLy8gQWxsIHNsYXRlIGNoYW5nZXMgZmlyZSB0aGUgb25DaGFuZ2UgZXZlbnRcbiAgLy8gaW5jbHVkaW5nIHNlbGVjdGlvbiBjaGFuZ2VzXG4gIC8vIHNvIHdlIHdpbGwgZmlsdGVyIHRoZSBzZXRfc2VsZWN0aW9uIG9wZXJhdGlvbnMgb3V0XG4gIC8vIGFuZCBvbmx5IGZpcmUgc2V0VmFsdWUgd2hlbiBvbkNoYW5nZSBpcyBiZWNhdXNlIG9mIHZhbHVlXG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgICh2YWw6IHVua25vd24pID0+IHtcbiAgICAgIGNvbnN0IG9wcyA9IGVkaXRvci5vcGVyYXRpb25zLmZpbHRlcigobzogQmFzZU9wZXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgIHJldHVybiBvLnR5cGUgIT09ICdzZXRfc2VsZWN0aW9uJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSlcblxuICAgICAgaWYgKG9wcyAmJiBBcnJheS5pc0FycmF5KG9wcykgJiYgb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCFyZWFkT25seSAmJiB2YWwgIT09IGRlZmF1bHRSaWNoVGV4dFZhbHVlICYmIHZhbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBzZXRWYWx1ZSh2YWwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtlZGl0b3Iub3BlcmF0aW9ucywgcmVhZE9ubHksIHNldFZhbHVlLCB2YWx1ZV0sXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbG9hZGVkKSB7XG4gICAgICBjb25zdCBtZXJnZWRFbGVtZW50cyA9IG1lcmdlQ3VzdG9tRnVuY3Rpb25zKGVsZW1lbnRzLCBlbGVtZW50VHlwZXMpXG4gICAgICBjb25zdCBtZXJnZWRMZWF2ZXMgPSBtZXJnZUN1c3RvbUZ1bmN0aW9ucyhsZWF2ZXMsIGxlYWZUeXBlcylcblxuICAgICAgc2V0RW5hYmxlZEVsZW1lbnRzKG1lcmdlZEVsZW1lbnRzKVxuICAgICAgc2V0RW5hYmxlZExlYXZlcyhtZXJnZWRMZWF2ZXMpXG5cbiAgICAgIHNldExvYWRlZCh0cnVlKVxuICAgIH1cbiAgfSwgW2xvYWRlZCwgZWxlbWVudHMsIGxlYXZlc10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiBzZXRDbGlja2FibGVTdGF0ZShjbGlja1N0YXRlOiAnZGlzYWJsZWQnIHwgJ2VuYWJsZWQnKSB7XG4gICAgICBjb25zdCBzZWxlY3RvcnMgPSAnYnV0dG9uLCBhLCBbcm9sZT1cImJ1dHRvblwiXSdcbiAgICAgIGNvbnN0IHRvb2xiYXJCdXR0b25zOiAoSFRNTEFuY2hvckVsZW1lbnQgfCBIVE1MQnV0dG9uRWxlbWVudClbXSA9XG4gICAgICAgIHRvb2xiYXJSZWYuY3VycmVudD8ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMpXG5cbiAgICAgIDsodG9vbGJhckJ1dHRvbnMgfHwgW10pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzQnV0dG9uID0gY2hpbGQudGFnTmFtZSA9PT0gJ0JVVFRPTidcbiAgICAgICAgY29uc3QgaXNEaXNhYmxpbmcgPSBjbGlja1N0YXRlID09PSAnZGlzYWJsZWQnXG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCBpc0Rpc2FibGluZyA/ICctMScgOiAnMCcpXG4gICAgICAgIGlmIChpc0J1dHRvbikgY2hpbGQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIGlzRGlzYWJsaW5nID8gJ2Rpc2FibGVkJyA6IG51bGwpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChsb2FkZWQgJiYgcmVhZE9ubHkpIHtcbiAgICAgIHNldENsaWNrYWJsZVN0YXRlKCdkaXNhYmxlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChsb2FkZWQgJiYgcmVhZE9ubHkpIHtcbiAgICAgICAgc2V0Q2xpY2thYmxlU3RhdGUoJ2VuYWJsZWQnKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2xvYWRlZCwgcmVhZE9ubHldKVxuXG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XG4gIC8vICAgLy8gSWYgdGhlcmUgaXMgYSBjaGFuZ2UgdG8gdGhlIGluaXRpYWwgdmFsdWUsIHdlIG5lZWQgdG8gcmVzZXQgU2xhdGUgaGlzdG9yeVxuICAvLyAgIC8vIGFuZCBjbGVhciBzZWxlY3Rpb24gYmVjYXVzZSB0aGUgb2xkIHNlbGVjdGlvbiBtYXkgbm8gbG9uZ2VyIGJlIHZhbGlkXG4gIC8vICAgLy8gYXMgcmV0dXJuZWQgSlNPTiBtYXkgYmUgbW9kaWZpZWQgaW4gaG9va3MgYW5kIGhhdmUgYSBkaWZmZXJlbnQgc2hhcGVcbiAgLy8gICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAvLyAgICAgY29uc29sZS5sb2coJ2Rlc2VsZWN0aW5nJyk7XG4gIC8vICAgICBSZWFjdEVkaXRvci5kZXNlbGVjdChlZGl0b3IpO1xuICAvLyAgIH1cbiAgLy8gfSwgW3BhdGgsIGVkaXRvcl0pO1xuXG4gIGlmICghbG9hZGVkKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxldCB2YWx1ZVRvUmVuZGVyID0gdmFsdWVcblxuICBpZiAodHlwZW9mIHZhbHVlVG9SZW5kZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZEpTT04gPSBKU09OLnBhcnNlKHZhbHVlVG9SZW5kZXIpXG4gICAgICB2YWx1ZVRvUmVuZGVyID0gcGFyc2VkSlNPTlxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdmFsdWVUb1JlbmRlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBpZiAoIXZhbHVlVG9SZW5kZXIpIHZhbHVlVG9SZW5kZXIgPSBkZWZhdWx0VmFsdWVGcm9tUHJvcHMgfHwgZGVmYXVsdFJpY2hUZXh0VmFsdWVcblxuICBjb25zdCBFcnJvckNvbXAgPSBFcnJvciB8fCBEZWZhdWx0RXJyb3JcbiAgY29uc3QgTGFiZWxDb21wID0gTGFiZWwgfHwgRGVmYXVsdExhYmVsXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICBzdHlsZT17e1xuICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgd2lkdGgsXG4gICAgICB9fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X193cmFwYH0+XG4gICAgICAgIDxFcnJvckNvbXAgbWVzc2FnZT17ZXJyb3JNZXNzYWdlfSBzaG93RXJyb3I9e3Nob3dFcnJvcn0gLz5cbiAgICAgICAgPExhYmVsQ29tcFxuICAgICAgICAgIGh0bWxGb3I9e2BmaWVsZC0ke3BhdGgucmVwbGFjZSgvXFwuL2csICdfXycpfWB9XG4gICAgICAgICAgbGFiZWw9e2xhYmVsfVxuICAgICAgICAgIHJlcXVpcmVkPXtyZXF1aXJlZH1cbiAgICAgICAgLz5cbiAgICAgICAgPFNsYXRlXG4gICAgICAgICAgZWRpdG9yPXtlZGl0b3J9XG4gICAgICAgICAga2V5PXtKU09OLnN0cmluZ2lmeSh7IGluaXRpYWxWYWx1ZSwgcGF0aCB9KX0gLy8gbWFrZXMgc3VyZSBzbGF0ZSBpcyBjb21wbGV0ZWx5IHJlLXJlbmRlcmVkIHdoZW4gaW5pdGlhbFZhbHVlIGNoYW5nZXMsIGJ5cGFzc2luZyB0aGUgc2xhdGUtaW50ZXJuYWwgdmFsdWUgbWVtb2l6YXRpb24uIFRoYXQgd2F5LCBleHRlcm5hbCBjaGFuZ2VzIHRvIHRoZSBmb3JtIHdpbGwgdXBkYXRlIHRoZSBlZGl0b3JcbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZVRvUmVuZGVyIGFzIGFueVtdfVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX3dyYXBwZXJgfT5cbiAgICAgICAgICAgIHtlbGVtZW50cz8ubGVuZ3RoICsgbGVhdmVzPy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17W2Ake2Jhc2VDbGFzc31fX3Rvb2xiYXJgLCBkcmF3ZXJJc09wZW4gJiYgYCR7YmFzZUNsYXNzfV9fZHJhd2VySXNPcGVuYF1cbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyl9XG4gICAgICAgICAgICAgICAgcmVmPXt0b29sYmFyUmVmfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX3Rvb2xiYXItd3JhcGB9PlxuICAgICAgICAgICAgICAgICAge2VsZW1lbnRzLm1hcCgoZWxlbWVudCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudE5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQ/Lm5hbWUpIGVsZW1lbnROYW1lID0gZWxlbWVudC5uYW1lXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIGVsZW1lbnROYW1lID0gZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gZW5hYmxlZEVsZW1lbnRzW2VsZW1lbnROYW1lXVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBCdXR0b24gPSBlbGVtZW50VHlwZT8uQnV0dG9uXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnV0dG9uIGZpZWxkUHJvcHM9e3Byb3BzfSBrZXk9e2l9IHBhdGg9e3BhdGh9IC8+XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICB7bGVhdmVzLm1hcCgobGVhZiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVhZk5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxlYWYgPT09ICdvYmplY3QnICYmIGxlYWY/Lm5hbWUpIGxlYWZOYW1lID0gbGVhZi5uYW1lXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGVhZiA9PT0gJ3N0cmluZycpIGxlYWZOYW1lID0gbGVhZlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYWZUeXBlID0gZW5hYmxlZExlYXZlc1tsZWFmTmFtZV1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQnV0dG9uID0gbGVhZlR5cGU/LkJ1dHRvblxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPEJ1dHRvbiBmaWVsZFByb3BzPXtwcm9wc30ga2V5PXtpfSBwYXRoPXtwYXRofSAvPlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fZWRpdG9yYH0gcmVmPXtlZGl0b3JSZWZ9PlxuICAgICAgICAgICAgICA8RWRpdGFibGVcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2lucHV0YH1cbiAgICAgICAgICAgICAgICBpZD17YGZpZWxkLSR7cGF0aC5yZXBsYWNlKC9cXC4vZywgJ19fJyl9YH1cbiAgICAgICAgICAgICAgICBvbktleURvd249eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydFRleHQoJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gTm9kZS5kZXNjZW5kYW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IucGF0aC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFNsYXRlRWxlbWVudC5pc0VsZW1lbnQoc2VsZWN0ZWRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgaGFyZCBlbnRlciB0byBcImJyZWFrIG91dFwiIG9mIGNlcnRhaW4gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3Iuc2hvdWxkQnJlYWtPdXRPbkVudGVyKHNlbGVjdGVkRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZExlYWYgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvci5wYXRoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZXh0LmlzVGV4dChzZWxlY3RlZExlYWYpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nKHNlbGVjdGVkTGVhZi50ZXh0KS5sZW5ndGggPT09IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgeyBjaGlsZHJlbjogW3sgdGV4dDogJycgfV0gfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBOb2RlLmRlc2NlbmRhbnQoXG4gICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLnBhdGguc2xpY2UoMCwgLTEpLFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFNsYXRlRWxlbWVudC5pc0VsZW1lbnQoc2VsZWN0ZWRFbGVtZW50KSAmJiBzZWxlY3RlZEVsZW1lbnQudHlwZSA9PT0gJ2xpJykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTGVhZiA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLnBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFRleHQuaXNUZXh0KHNlbGVjdGVkTGVhZikgJiYgU3RyaW5nKHNlbGVjdGVkTGVhZi50ZXh0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiAobikgPT4gU2xhdGVFbGVtZW50LmlzRWxlbWVudChuKSAmJiBsaXN0VHlwZXMuaW5jbHVkZXMobi50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHsgdHlwZTogdW5kZWZpbmVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc1ZvaWQoc2VsZWN0ZWRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGhvdGtleXMpLmZvckVhY2goKGhvdGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudCBhcyBhbnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsgPSBob3RrZXlzW2hvdGtleV1cbiAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVMZWFmKGVkaXRvciwgbWFyaylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtnZXRUcmFuc2xhdGlvbihwbGFjZWhvbGRlciwgaTE4bil9XG4gICAgICAgICAgICAgICAgcmVhZE9ubHk9e3JlYWRPbmx5fVxuICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQ9e3JlbmRlckVsZW1lbnR9XG4gICAgICAgICAgICAgICAgcmVuZGVyTGVhZj17cmVuZGVyTGVhZn1cbiAgICAgICAgICAgICAgICBzcGVsbENoZWNrXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9TbGF0ZT5cbiAgICAgICAgPEZpZWxkRGVzY3JpcHRpb24gZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufSBwYXRoPXtwYXRofSB2YWx1ZT17dmFsdWV9IC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuZXhwb3J0IGRlZmF1bHQgd2l0aENvbmRpdGlvbihSaWNoVGV4dClcbiJdLCJuYW1lcyI6WyJkZWZhdWx0RWxlbWVudHMiLCJkZWZhdWx0TGVhdmVzIiwiYmFzZUNsYXNzIiwiUmljaFRleHQiLCJwcm9wcyIsIm5hbWUiLCJhZG1pbiIsImNsYXNzTmFtZSIsImNvbXBvbmVudHMiLCJFcnJvciIsIkxhYmVsIiwiY29uZGl0aW9uIiwiZGVzY3JpcHRpb24iLCJoaWRlR3V0dGVyIiwicGxhY2Vob2xkZXIiLCJyZWFkT25seSIsInN0eWxlIiwid2lkdGgiLCJ1bmRlZmluZWQiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0VmFsdWVGcm9tUHJvcHMiLCJsYWJlbCIsInBhdGgiLCJwYXRoRnJvbVByb3BzIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsInJpY2hUZXh0VmFsaWRhdGUiLCJlbGVtZW50cyIsImxlYXZlcyIsImkxOG4iLCJ1c2VUcmFuc2xhdGlvbiIsImxvYWRlZCIsInNldExvYWRlZCIsInVzZVN0YXRlIiwiZW5hYmxlZEVsZW1lbnRzIiwic2V0RW5hYmxlZEVsZW1lbnRzIiwiZW5hYmxlZExlYXZlcyIsInNldEVuYWJsZWRMZWF2ZXMiLCJlZGl0b3JSZWYiLCJ1c2VSZWYiLCJ0b29sYmFyUmVmIiwiZHJhd2VyRGVwdGgiLCJ1c2VFZGl0RGVwdGgiLCJkcmF3ZXJJc09wZW4iLCJyZW5kZXJFbGVtZW50IiwidXNlQ2FsbGJhY2siLCJhdHRyaWJ1dGVzIiwiY2hpbGRyZW4iLCJlbGVtZW50IiwibWF0Y2hlZEVsZW1lbnQiLCJ0eXBlIiwiRWxlbWVudCIsImF0dHIiLCJ0ZXh0QWxpZ24iLCJtYXJnaW5SaWdodCIsIm1hcmdpbkxlZnQiLCJsaXN0U3R5bGVQb3NpdGlvbiIsImVsIiwiZmllbGRQcm9wcyIsImRpdiIsInJlbmRlckxlYWYiLCJsZWFmIiwibWF0Y2hlZExlYXZlcyIsIk9iamVjdCIsImVudHJpZXMiLCJmaWx0ZXIiLCJsZWFmTmFtZSIsImxlbmd0aCIsInJlZHVjZSIsInJlc3VsdCIsImkiLCJMZWFmIiwia2V5Iiwic3BhbiIsIm1lbW9pemVkVmFsaWRhdGUiLCJ2YWx1ZSIsInZhbGlkYXRpb25PcHRpb25zIiwiZmllbGRUeXBlIiwidXNlRmllbGQiLCJlcnJvck1lc3NhZ2UiLCJpbml0aWFsVmFsdWUiLCJzZXRWYWx1ZSIsInNob3dFcnJvciIsImNsYXNzZXMiLCJCb29sZWFuIiwiam9pbiIsImVkaXRvciIsInVzZU1lbW8iLCJDcmVhdGVkRWRpdG9yIiwid2l0aEVudGVyQnJlYWtPdXQiLCJ3aXRoSGlzdG9yeSIsIndpdGhSZWFjdCIsImNyZWF0ZUVkaXRvciIsIndpdGhIVE1MIiwiZW5hYmxlUGx1Z2lucyIsImhhbmRsZUNoYW5nZSIsInZhbCIsIm9wcyIsIm9wZXJhdGlvbnMiLCJvIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVmYXVsdFJpY2hUZXh0VmFsdWUiLCJ1c2VFZmZlY3QiLCJtZXJnZWRFbGVtZW50cyIsIm1lcmdlQ3VzdG9tRnVuY3Rpb25zIiwiZWxlbWVudFR5cGVzIiwibWVyZ2VkTGVhdmVzIiwibGVhZlR5cGVzIiwic2V0Q2xpY2thYmxlU3RhdGUiLCJjbGlja1N0YXRlIiwic2VsZWN0b3JzIiwidG9vbGJhckJ1dHRvbnMiLCJjdXJyZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJjaGlsZCIsImlzQnV0dG9uIiwidGFnTmFtZSIsImlzRGlzYWJsaW5nIiwic2V0QXR0cmlidXRlIiwidmFsdWVUb1JlbmRlciIsInBhcnNlZEpTT04iLCJKU09OIiwicGFyc2UiLCJlcnIiLCJFcnJvckNvbXAiLCJEZWZhdWx0RXJyb3IiLCJMYWJlbENvbXAiLCJEZWZhdWx0TGFiZWwiLCJtZXNzYWdlIiwiaHRtbEZvciIsInJlcGxhY2UiLCJTbGF0ZSIsInN0cmluZ2lmeSIsIm9uQ2hhbmdlIiwicmVmIiwibWFwIiwiZWxlbWVudE5hbWUiLCJlbGVtZW50VHlwZSIsIkJ1dHRvbiIsImxlYWZUeXBlIiwiRWRpdGFibGUiLCJpZCIsIm9uS2V5RG93biIsImV2ZW50Iiwic2hpZnRLZXkiLCJwcmV2ZW50RGVmYXVsdCIsImluc2VydFRleHQiLCJzZWxlY3RlZEVsZW1lbnQiLCJOb2RlIiwiZGVzY2VuZGFudCIsInNlbGVjdGlvbiIsImFuY2hvciIsInNsaWNlIiwiU2xhdGVFbGVtZW50IiwiaXNFbGVtZW50Iiwic2hvdWxkQnJlYWtPdXRPbkVudGVyIiwic2VsZWN0ZWRMZWFmIiwiVGV4dCIsImlzVGV4dCIsIlN0cmluZyIsInRleHQiLCJvZmZzZXQiLCJUcmFuc2Zvcm1zIiwiaW5zZXJ0Tm9kZXMiLCJzcGxpdE5vZGVzIiwic2V0Tm9kZXMiLCJ1bndyYXBOb2RlcyIsIm1hdGNoIiwibiIsImxpc3RUeXBlcyIsImluY2x1ZGVzIiwibW9kZSIsInNwbGl0IiwiaXNWb2lkIiwicmVtb3ZlTm9kZXMiLCJrZXlzIiwiaG90a2V5cyIsImhvdGtleSIsImlzSG90a2V5IiwibWFyayIsInRvZ2dsZUxlYWYiLCJnZXRUcmFuc2xhdGlvbiIsInNwZWxsQ2hlY2siLCJGaWVsZERlc2NyaXB0aW9uIiwid2l0aENvbmRpdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OytCQW1kQTs7O2VBQUE7OztpRUE3Y3FCO3VCQU9kOzJCQUNzQjs0QkFDRTsrREFDMEM7OEJBQzFDO3VCQUMrQzs4QkFDbEQ7NEJBQ2U7OEJBSU47NEJBQ0o7aUVBQ1I7a0VBQ0g7c0VBQ0k7Z0VBQ047UUFDYjsrREFDZTsrREFDQzs2RUFDVTswRUFDSDtpRUFDVDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFckIsTUFBTUEsa0JBQXFDO0lBQ3pDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsZ0JBQWdDO0lBQUM7SUFBUTtJQUFVO0lBQWE7SUFBaUI7Q0FBTztBQUU5RixNQUFNQyxZQUFZO0FBVWxCLE1BQU1DLFdBQWlDLENBQUNDO0lBQ3RDLE1BQU0sRUFDSkMsSUFBSSxFQUNKQyxPQUFPLEVBQ0xDLFNBQVMsRUFDVEMsWUFBWSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUNqQ0MsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsS0FBSyxFQUNOLEdBQUc7UUFDRlYsV0FBV1c7UUFDWFYsWUFBWSxDQUFDO1FBQ2JHLFdBQVdPO1FBQ1hOLGFBQWFNO1FBQ2JMLFlBQVlLO1FBQ1pKLGFBQWFJO1FBQ2JILFVBQVVHO1FBQ1ZGLE9BQU9FO1FBQ1BELE9BQU9DO0lBQ1QsQ0FBQyxFQUNEWixLQUFLLEVBQ0xhLGNBQWNDLHFCQUFxQixFQUNuQ0MsS0FBSyxFQUNMQyxNQUFNQyxhQUFhLEVBQ25CQyxRQUFRLEVBQ1JDLFdBQVdDLDRCQUFnQixFQUM1QixHQUFHdEI7SUFFSixNQUFNdUIsV0FBOEJyQixPQUFPcUIsWUFBWTNCO0lBQ3ZELE1BQU00QixTQUF5QnRCLE9BQU9zQixVQUFVM0I7SUFFaEQsTUFBTXFCLE9BQU9DLGlCQUFpQmxCO0lBRTlCLE1BQU0sRUFBRXdCLElBQUksRUFBRSxHQUFHQyxJQUFBQSw0QkFBYztJQUMvQixNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR0MsSUFBQUEsZUFBUSxFQUFDO0lBQ3JDLE1BQU0sQ0FBQ0MsaUJBQWlCQyxtQkFBbUIsR0FBR0YsSUFBQUEsZUFBUSxFQUFDLENBQUM7SUFDeEQsTUFBTSxDQUFDRyxlQUFlQyxpQkFBaUIsR0FBR0osSUFBQUEsZUFBUSxFQUFDLENBQUM7SUFDcEQsTUFBTUssWUFBWUMsSUFBQUEsYUFBTSxFQUFDO0lBQ3pCLE1BQU1DLGFBQWFELElBQUFBLGFBQU0sRUFBQztJQUUxQixNQUFNRSxjQUFjQyxJQUFBQSx1QkFBWTtJQUNoQyxNQUFNQyxlQUFlRixjQUFjO0lBRW5DLE1BQU1HLGdCQUFnQkMsSUFBQUEsa0JBQVcsRUFDL0IsQ0FBQyxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLE1BQU1DLGlCQUFpQmYsZUFBZSxDQUFDYyxRQUFRRSxJQUFJLENBQUM7UUFDcEQsTUFBTUMsVUFBVUYsZ0JBQWdCRTtRQUVoQyxJQUFJQyxPQUFPO1lBQUUsR0FBR04sVUFBVTtRQUFDO1FBRTNCLHlFQUF5RTtRQUN6RSxJQUFJRSxRQUFRSyxTQUFTLEVBQUU7WUFDckIsSUFBSUwsUUFBUUUsSUFBSSxLQUFLLGtCQUFrQkYsUUFBUUUsSUFBSSxLQUFLLFVBQVU7Z0JBQ2hFLE9BQVFGLFFBQVFLLFNBQVM7b0JBQ3ZCLEtBQUs7d0JBQ0hELE9BQU87NEJBQUUsR0FBR0EsSUFBSTs0QkFBRXBDLE9BQU87Z0NBQUVzQyxhQUFhOzRCQUFPO3dCQUFFO3dCQUNqRDtvQkFDRixLQUFLO3dCQUNIRixPQUFPOzRCQUFFLEdBQUdBLElBQUk7NEJBQUVwQyxPQUFPO2dDQUFFdUMsWUFBWTs0QkFBTzt3QkFBRTt3QkFDaEQ7b0JBQ0YsS0FBSzt3QkFDSEgsT0FBTzs0QkFBRSxHQUFHQSxJQUFJOzRCQUFFcEMsT0FBTztnQ0FBRXVDLFlBQVk7Z0NBQVFELGFBQWE7NEJBQU87d0JBQUU7d0JBQ3JFO29CQUNGO3dCQUNFRixPQUFPOzRCQUFFLEdBQUdBLElBQUk7NEJBQUVwQyxPQUFPO2dDQUFFcUMsV0FBV0wsUUFBUUssU0FBUzs0QkFBQzt3QkFBRTt3QkFDMUQ7Z0JBQ0o7WUFDRixPQUFPLElBQUlMLFFBQVFFLElBQUksS0FBSyxNQUFNO2dCQUNoQyxPQUFRRixRQUFRSyxTQUFTO29CQUN2QixLQUFLO3dCQUNIRCxPQUFPOzRCQUFFLEdBQUdBLElBQUk7NEJBQUVwQyxPQUFPO2dDQUFFd0MsbUJBQW1CO2dDQUFVSCxXQUFXOzRCQUFRO3dCQUFFO3dCQUM3RTtvQkFDRixLQUFLO3dCQUNIRCxPQUFPOzRCQUFFLEdBQUdBLElBQUk7NEJBQUVwQyxPQUFPO2dDQUFFd0MsbUJBQW1CO2dDQUFVSCxXQUFXOzRCQUFTO3dCQUFFO3dCQUM5RTtvQkFDRixLQUFLO29CQUNMO3dCQUNFRCxPQUFPOzRCQUFFLEdBQUdBLElBQUk7NEJBQUVwQyxPQUFPO2dDQUFFd0MsbUJBQW1CO2dDQUFXSCxXQUFXOzRCQUFPO3dCQUFFO3dCQUM3RTtnQkFDSjtZQUNGLE9BQU87Z0JBQ0xELE9BQU87b0JBQUUsR0FBR0EsSUFBSTtvQkFBRXBDLE9BQU87d0JBQUVxQyxXQUFXTCxRQUFRSyxTQUFTO29CQUFDO2dCQUFFO1lBQzVEO1FBQ0Y7UUFFQSxJQUFJRixTQUFTO1lBQ1gsTUFBTU0sbUJBQ0osNkJBQUNOO2dCQUNDTCxZQUFZTTtnQkFDWmQsV0FBV0E7Z0JBQ1hVLFNBQVNBO2dCQUNUVSxZQUFZdEQ7Z0JBQ1prQixNQUFNQTtlQUVMeUI7WUFJTCxPQUFPVTtRQUNUO1FBRUEscUJBQU8sNkJBQUNFLE9BQVFQLE1BQU9MO0lBQ3pCLEdBQ0E7UUFBQ2I7UUFBaUJaO1FBQU1sQjtLQUFNO0lBR2hDLE1BQU13RCxhQUFhZixJQUFBQSxrQkFBVyxFQUM1QixDQUFDLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFYyxJQUFJLEVBQUU7UUFDN0IsTUFBTUMsZ0JBQWdCQyxPQUFPQyxPQUFPLENBQUM1QixlQUFlNkIsTUFBTSxDQUFDLENBQUMsQ0FBQ0MsU0FBUyxHQUFLTCxJQUFJLENBQUNLLFNBQVM7UUFFekYsSUFBSUosY0FBY0ssTUFBTSxHQUFHLEdBQUc7WUFDNUIsT0FBT0wsY0FBY00sTUFBTSxDQUN6QixDQUFDQyxRQUFRLENBQUNILFNBQVMsRUFBRUk7Z0JBQ25CLElBQUlsQyxhQUFhLENBQUM4QixTQUFTLEVBQUVLLE1BQU07b0JBQ2pDLE1BQU1BLE9BQU9uQyxhQUFhLENBQUM4QixTQUFTLEVBQUVLO29CQUN0QyxxQkFDRSw2QkFBQ0E7d0JBQUtqQyxXQUFXQTt3QkFBV29CLFlBQVl0RDt3QkFBT29FLEtBQUtGO3dCQUFHVCxNQUFNQTt3QkFBTXZDLE1BQU1BO3VCQUN0RStDO2dCQUdQO2dCQUVBLE9BQU9BO1lBQ1QsaUJBQ0EsNkJBQUNJLFFBQVMzQixZQUFhQztRQUUzQjtRQUVBLHFCQUFPLDZCQUFDMEIsUUFBUzNCLFlBQWFDO0lBQ2hDLEdBQ0E7UUFBQ1g7UUFBZWQ7UUFBTWxCO0tBQU07SUFHOUIsTUFBTXNFLG1CQUFtQjdCLElBQUFBLGtCQUFXLEVBQ2xDLENBQUM4QixPQUFPQztRQUNOLE9BQU9uRCxTQUFTa0QsT0FBTztZQUFFLEdBQUdDLGlCQUFpQjtZQUFFcEQ7UUFBUztJQUMxRCxHQUNBO1FBQUNDO1FBQVVEO0tBQVM7SUFHdEIsTUFBTXFELFlBQVlDLElBQUFBLGVBQVEsRUFBQztRQUN6Qm5FO1FBQ0FXO1FBQ0FHLFVBQVVpRDtJQUNaO0lBRUEsTUFBTSxFQUFFSyxZQUFZLEVBQUVDLFlBQVksRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVQLEtBQUssRUFBRSxHQUFHRTtJQUVuRSxNQUFNTSxVQUFVO1FBQ2RqRjtRQUNBO1FBQ0FLO1FBQ0EyRSxhQUFhO1FBQ2JuRSxZQUFZLENBQUMsRUFBRWIsVUFBVSxXQUFXLENBQUM7UUFDckMsQ0FBQ1csY0FBYyxDQUFDLEVBQUVYLFVBQVUsUUFBUSxDQUFDO0tBQ3RDLENBQ0UrRCxNQUFNLENBQUNtQixTQUNQQyxJQUFJLENBQUM7SUFFUixNQUFNQyxTQUFTQyxJQUFBQSxjQUFPLEVBQUM7UUFDckIsSUFBSUMsZ0JBQWdCQyxJQUFBQSwwQkFBaUIsRUFBQ0MsSUFBQUEseUJBQVcsRUFBQ0MsSUFBQUEscUJBQVMsRUFBQ0MsSUFBQUEsbUJBQVk7UUFFeEVKLGdCQUFnQkssSUFBQUEsaUJBQVEsRUFBQ0w7UUFDekJBLGdCQUFnQk0sSUFBQUEsc0JBQWEsRUFBQ04sZUFBZTdEO1FBQzdDNkQsZ0JBQWdCTSxJQUFBQSxzQkFBYSxFQUFDTixlQUFlNUQ7UUFFN0MsT0FBTzREO0lBQ1AsdURBQXVEO0lBQ3pELEdBQUc7UUFBQzdEO1FBQVVDO1FBQVFOO0tBQUs7SUFFM0IsNENBQTRDO0lBQzVDLDhCQUE4QjtJQUM5QixxREFBcUQ7SUFDckQsMkRBQTJEO0lBQzNELE1BQU15RSxlQUFlbEQsSUFBQUEsa0JBQVcsRUFDOUIsQ0FBQ21EO1FBQ0MsTUFBTUMsTUFBTVgsT0FBT1ksVUFBVSxDQUFDakMsTUFBTSxDQUFDLENBQUNrQztZQUNwQyxJQUFJQSxHQUFHO2dCQUNMLE9BQU9BLEVBQUVqRCxJQUFJLEtBQUs7WUFDcEI7WUFDQSxPQUFPO1FBQ1Q7UUFFQSxJQUFJK0MsT0FBT0csTUFBTUMsT0FBTyxDQUFDSixRQUFRQSxJQUFJOUIsTUFBTSxHQUFHLEdBQUc7WUFDL0MsSUFBSSxDQUFDcEQsWUFBWWlGLFFBQVFNLGtDQUFvQixJQUFJTixRQUFRckIsT0FBTztnQkFDOURNLFNBQVNlO1lBQ1g7UUFDRjtJQUNGLEdBQ0E7UUFBQ1YsT0FBT1ksVUFBVTtRQUFFbkY7UUFBVWtFO1FBQVVOO0tBQU07SUFHaEQ0QixJQUFBQSxnQkFBUyxFQUFDO1FBQ1IsSUFBSSxDQUFDeEUsUUFBUTtZQUNYLE1BQU15RSxpQkFBaUJDLElBQUFBLDZCQUFvQixFQUFDOUUsVUFBVStFLGlCQUFZO1lBQ2xFLE1BQU1DLGVBQWVGLElBQUFBLDZCQUFvQixFQUFDN0UsUUFBUWdGLGVBQVM7WUFFM0R6RSxtQkFBbUJxRTtZQUNuQm5FLGlCQUFpQnNFO1lBRWpCM0UsVUFBVTtRQUNaO0lBQ0YsR0FBRztRQUFDRDtRQUFRSjtRQUFVQztLQUFPO0lBRTdCMkUsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLFNBQVNNLGtCQUFrQkMsVUFBa0M7WUFDM0QsTUFBTUMsWUFBWTtZQUNsQixNQUFNQyxpQkFDSnhFLFdBQVd5RSxPQUFPLEVBQUVDLGlCQUFpQkg7WUFFckNDLENBQUFBLGtCQUFrQixFQUFFLEFBQUQsRUFBR0csT0FBTyxDQUFDLENBQUNDO2dCQUMvQixNQUFNQyxXQUFXRCxNQUFNRSxPQUFPLEtBQUs7Z0JBQ25DLE1BQU1DLGNBQWNULGVBQWU7Z0JBQ25DTSxNQUFNSSxZQUFZLENBQUMsWUFBWUQsY0FBYyxPQUFPO2dCQUNwRCxJQUFJRixVQUFVRCxNQUFNSSxZQUFZLENBQUMsWUFBWUQsY0FBYyxhQUFhO1lBQzFFO1FBQ0Y7UUFFQSxJQUFJeEYsVUFBVWhCLFVBQVU7WUFDdEI4RixrQkFBa0I7UUFDcEI7UUFFQSxPQUFPO1lBQ0wsSUFBSTlFLFVBQVVoQixVQUFVO2dCQUN0QjhGLGtCQUFrQjtZQUNwQjtRQUNGO0lBQ0YsR0FBRztRQUFDOUU7UUFBUWhCO0tBQVM7SUFFckIsb0JBQW9CO0lBQ3BCLGlGQUFpRjtJQUNqRiw0RUFBNEU7SUFDNUUsNEVBQTRFO0lBQzVFLDRCQUE0QjtJQUM1QixrQ0FBa0M7SUFDbEMsb0NBQW9DO0lBQ3BDLE1BQU07SUFDTixzQkFBc0I7SUFFdEIsSUFBSSxDQUFDZ0IsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUVBLElBQUkwRixnQkFBZ0I5QztJQUVwQixJQUFJLE9BQU84QyxrQkFBa0IsVUFBVTtRQUNyQyxJQUFJO1lBQ0YsTUFBTUMsYUFBYUMsS0FBS0MsS0FBSyxDQUFDSDtZQUM5QkEsZ0JBQWdCQztRQUNsQixFQUFFLE9BQU9HLEtBQUs7WUFDWkosZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFFQSxJQUFJLENBQUNBLGVBQWVBLGdCQUFnQnJHLHlCQUF5QmtGLGtDQUFvQjtJQUVqRixNQUFNd0IsWUFBWXJILFNBQVNzSCxZQUFZO0lBQ3ZDLE1BQU1DLFlBQVl0SCxTQUFTdUgsWUFBWTtJQUV2QyxxQkFDRSw2QkFBQ3RFO1FBQ0NwRCxXQUFXNEU7UUFDWG5FLE9BQU87WUFDTCxHQUFHQSxLQUFLO1lBQ1JDO1FBQ0Y7cUJBRUEsNkJBQUMwQztRQUFJcEQsV0FBVyxDQUFDLEVBQUVMLFVBQVUsTUFBTSxDQUFDO3FCQUNsQyw2QkFBQzRIO1FBQVVJLFNBQVNuRDtRQUFjRyxXQUFXQTtzQkFDN0MsNkJBQUM4QztRQUNDRyxTQUFTLENBQUMsTUFBTSxFQUFFN0csS0FBSzhHLE9BQU8sQ0FBQyxPQUFPLE1BQU0sQ0FBQztRQUM3Qy9HLE9BQU9BO1FBQ1BHLFVBQVVBO3NCQUVaLDZCQUFDNkcsaUJBQUs7UUFDSi9DLFFBQVFBO1FBQ1JkLEtBQUttRCxLQUFLVyxTQUFTLENBQUM7WUFBRXREO1lBQWMxRDtRQUFLO1FBQ3pDaUgsVUFBVXhDO1FBQ1ZwQixPQUFPOEM7cUJBRVAsNkJBQUM5RDtRQUFJcEQsV0FBVyxDQUFDLEVBQUVMLFVBQVUsU0FBUyxDQUFDO09BQ3BDeUIsVUFBVXdDLFNBQVN2QyxRQUFRdUMsU0FBUyxtQkFDbkMsNkJBQUNSO1FBQ0NwRCxXQUFXO1lBQUMsQ0FBQyxFQUFFTCxVQUFVLFNBQVMsQ0FBQztZQUFFeUMsZ0JBQWdCLENBQUMsRUFBRXpDLFVBQVUsY0FBYyxDQUFDO1NBQUMsQ0FDL0UrRCxNQUFNLENBQUNtQixTQUNQQyxJQUFJLENBQUM7UUFDUm1ELEtBQUtoRztxQkFFTCw2QkFBQ21CO1FBQUlwRCxXQUFXLENBQUMsRUFBRUwsVUFBVSxjQUFjLENBQUM7T0FDekN5QixTQUFTOEcsR0FBRyxDQUFDLENBQUN6RixTQUFTc0I7UUFDdEIsSUFBSW9FO1FBQ0osSUFBSSxPQUFPMUYsWUFBWSxZQUFZQSxTQUFTM0MsTUFBTXFJLGNBQWMxRixRQUFRM0MsSUFBSTtRQUM1RSxJQUFJLE9BQU8yQyxZQUFZLFVBQVUwRixjQUFjMUY7UUFFL0MsTUFBTTJGLGNBQWN6RyxlQUFlLENBQUN3RyxZQUFZO1FBQ2hELE1BQU1FLFNBQVNELGFBQWFDO1FBRTVCLElBQUlBLFFBQVE7WUFDVixxQkFBTyw2QkFBQ0E7Z0JBQU9sRixZQUFZdEQ7Z0JBQU9vRSxLQUFLRjtnQkFBR2hELE1BQU1BOztRQUNsRDtRQUVBLE9BQU87SUFDVCxJQUNDTSxPQUFPNkcsR0FBRyxDQUFDLENBQUM1RSxNQUFNUztRQUNqQixJQUFJSjtRQUNKLElBQUksT0FBT0wsU0FBUyxZQUFZQSxNQUFNeEQsTUFBTTZELFdBQVdMLEtBQUt4RCxJQUFJO1FBQ2hFLElBQUksT0FBT3dELFNBQVMsVUFBVUssV0FBV0w7UUFFekMsTUFBTWdGLFdBQVd6RyxhQUFhLENBQUM4QixTQUFTO1FBQ3hDLE1BQU0wRSxTQUFTQyxVQUFVRDtRQUV6QixJQUFJQSxRQUFRO1lBQ1YscUJBQU8sNkJBQUNBO2dCQUFPbEYsWUFBWXREO2dCQUFPb0UsS0FBS0Y7Z0JBQUdoRCxNQUFNQTs7UUFDbEQ7UUFFQSxPQUFPO0lBQ1Qsb0JBSU4sNkJBQUNxQztRQUFJcEQsV0FBVyxDQUFDLEVBQUVMLFVBQVUsUUFBUSxDQUFDO1FBQUVzSSxLQUFLbEc7cUJBQzNDLDZCQUFDd0csb0JBQVE7UUFDUHZJLFdBQVcsQ0FBQyxFQUFFTCxVQUFVLE9BQU8sQ0FBQztRQUNoQzZJLElBQUksQ0FBQyxNQUFNLEVBQUV6SCxLQUFLOEcsT0FBTyxDQUFDLE9BQU8sTUFBTSxDQUFDO1FBQ3hDWSxXQUFXLENBQUNDO1lBQ1YsSUFBSUEsTUFBTXpFLEdBQUcsS0FBSyxTQUFTO2dCQUN6QixJQUFJeUUsTUFBTUMsUUFBUSxFQUFFO29CQUNsQkQsTUFBTUUsY0FBYztvQkFDcEI3RCxPQUFPOEQsVUFBVSxDQUFDO2dCQUNwQixPQUFPO29CQUNMLE1BQU1DLGtCQUFrQkMsV0FBSSxDQUFDQyxVQUFVLENBQ3JDakUsUUFDQUEsT0FBT2tFLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDbkksSUFBSSxDQUFDb0ksS0FBSyxDQUFDLEdBQUcsQ0FBQztvQkFHekMsSUFBSUMsY0FBWSxDQUFDQyxTQUFTLENBQUNQLGtCQUFrQjt3QkFDM0Msc0RBQXNEO3dCQUN0RCxJQUFJL0QsT0FBT3VFLHFCQUFxQixDQUFDUixrQkFBa0I7NEJBQ2pESixNQUFNRSxjQUFjOzRCQUNwQixNQUFNVyxlQUFlUixXQUFJLENBQUNDLFVBQVUsQ0FBQ2pFLFFBQVFBLE9BQU9rRSxTQUFTLENBQUNDLE1BQU0sQ0FBQ25JLElBQUk7NEJBRXpFLElBQ0V5SSxXQUFJLENBQUNDLE1BQU0sQ0FBQ0YsaUJBQ1pHLE9BQU9ILGFBQWFJLElBQUksRUFBRS9GLE1BQU0sS0FBS21CLE9BQU9rRSxTQUFTLENBQUNDLE1BQU0sQ0FBQ1UsTUFBTSxFQUNuRTtnQ0FDQUMsaUJBQVUsQ0FBQ0MsV0FBVyxDQUFDL0UsUUFBUTtvQ0FBRXZDLFVBQVU7d0NBQUM7NENBQUVtSCxNQUFNO3dDQUFHO3FDQUFFO2dDQUFDOzRCQUM1RCxPQUFPO2dDQUNMRSxpQkFBVSxDQUFDRSxVQUFVLENBQUNoRjtnQ0FDdEI4RSxpQkFBVSxDQUFDRyxRQUFRLENBQUNqRixRQUFRLENBQUM7NEJBQy9CO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJMkQsTUFBTXpFLEdBQUcsS0FBSyxhQUFhO2dCQUM3QixNQUFNNkUsa0JBQWtCQyxXQUFJLENBQUNDLFVBQVUsQ0FDckNqRSxRQUNBQSxPQUFPa0UsU0FBUyxDQUFDQyxNQUFNLENBQUNuSSxJQUFJLENBQUNvSSxLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUd6QyxJQUFJQyxjQUFZLENBQUNDLFNBQVMsQ0FBQ1Asb0JBQW9CQSxnQkFBZ0JuRyxJQUFJLEtBQUssTUFBTTtvQkFDNUUsTUFBTTRHLGVBQWVSLFdBQUksQ0FBQ0MsVUFBVSxDQUFDakUsUUFBUUEsT0FBT2tFLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDbkksSUFBSTtvQkFDekUsSUFBSXlJLFdBQUksQ0FBQ0MsTUFBTSxDQUFDRixpQkFBaUJHLE9BQU9ILGFBQWFJLElBQUksRUFBRS9GLE1BQU0sS0FBSyxHQUFHO3dCQUN2RThFLE1BQU1FLGNBQWM7d0JBQ3BCaUIsaUJBQVUsQ0FBQ0ksV0FBVyxDQUFDbEYsUUFBUTs0QkFDN0JtRixPQUFPLENBQUNDLElBQU1mLGNBQVksQ0FBQ0MsU0FBUyxDQUFDYyxNQUFNQyxrQkFBUyxDQUFDQyxRQUFRLENBQUNGLEVBQUV4SCxJQUFJOzRCQUNwRTJILE1BQU07NEJBQ05DLE9BQU87d0JBQ1Q7d0JBRUFWLGlCQUFVLENBQUNHLFFBQVEsQ0FBQ2pGLFFBQVE7NEJBQUVwQyxNQUFNaEM7d0JBQVU7b0JBQ2hEO2dCQUNGLE9BQU8sSUFBSW9FLE9BQU95RixNQUFNLENBQUMxQixrQkFBa0I7b0JBQ3pDZSxpQkFBVSxDQUFDWSxXQUFXLENBQUMxRjtnQkFDekI7WUFDRjtZQUVBdkIsT0FBT2tILElBQUksQ0FBQ0MsZ0JBQU8sRUFBRS9ELE9BQU8sQ0FBQyxDQUFDZ0U7Z0JBQzVCLElBQUlDLElBQUFBLGlCQUFRLEVBQUNELFFBQVFsQyxRQUFlO29CQUNsQ0EsTUFBTUUsY0FBYztvQkFDcEIsTUFBTWtDLE9BQU9ILGdCQUFPLENBQUNDLE9BQU87b0JBQzVCRyxJQUFBQSxlQUFVLEVBQUNoRyxRQUFRK0Y7Z0JBQ3JCO1lBQ0Y7UUFDRjtRQUNBdkssYUFBYXlLLElBQUFBLDBCQUFjLEVBQUN6SyxhQUFhZTtRQUN6Q2QsVUFBVUE7UUFDVjZCLGVBQWVBO1FBQ2ZnQixZQUFZQTtRQUNaNEgsWUFBQUE7eUJBS1IsNkJBQUNDLHVCQUFnQjtRQUFDN0ssYUFBYUE7UUFBYVUsTUFBTUE7UUFBTXFELE9BQU9BOztBQUl2RTtNQUNBLFdBQWUrRyxJQUFBQSxvQkFBYSxFQUFDdkwifQ==