"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _slate = require("slate");
const _slatereact = require("slate-react");
const _IndentLeft = /*#__PURE__*/ _interop_require_default(require("../../icons/IndentLeft"));
const _IndentRight = /*#__PURE__*/ _interop_require_default(require("../../icons/IndentRight"));
const _Button = require("../Button");
const _getCommonBlock = require("../getCommonBlock");
const _isActive = /*#__PURE__*/ _interop_require_default(require("../isActive"));
const _isBlockElement = require("../isBlockElement");
const _listTypes = /*#__PURE__*/ _interop_require_default(require("../listTypes"));
const _unwrapList = require("../unwrapList");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const indentType = 'indent';
const IndentWithPadding = ({ attributes, children })=>/*#__PURE__*/ _react.default.createElement("div", {
        style: {
            paddingLeft: 25
        },
        ...attributes
    }, children);
const indent = {
    Button: ()=>{
        const editor = (0, _slatereact.useSlate)();
        const handleIndent = (0, _react.useCallback)((e, dir)=>{
            e.preventDefault();
            if (dir === 'left') {
                if ((0, _isActive.default)(editor, 'li')) {
                    const [, listPath] = (0, _getCommonBlock.getCommonBlock)(editor, (n)=>_slate.Element.isElement(n) && _listTypes.default.includes(n.type));
                    const matchedParentList = _slate.Editor.above(editor, {
                        at: listPath,
                        match: (n)=>!_slate.Editor.isEditor(n) && (0, _isBlockElement.isBlockElement)(editor, n)
                    });
                    if (matchedParentList) {
                        const [parentListItem, parentListItemPath] = matchedParentList;
                        if (parentListItem.children.length > 1) {
                            // Remove nested list
                            _slate.Transforms.unwrapNodes(editor, {
                                at: parentListItemPath,
                                match: (node, path)=>{
                                    const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && _listTypes.default.includes(node.type) && path.length === parentListItemPath.length + 1;
                                    return matches;
                                }
                            });
                            // Set li type on any children that don't have a type
                            _slate.Transforms.setNodes(editor, {
                                type: 'li'
                            }, {
                                at: parentListItemPath,
                                match: (node, path)=>{
                                    const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && node.type !== 'li' && path.length === parentListItemPath.length + 1;
                                    return matches;
                                }
                            });
                            // Parent list item path has changed at this point
                            // so we need to re-fetch the parent node
                            const [newParentNode] = _slate.Editor.node(editor, parentListItemPath);
                            // If the parent node is an li,
                            // lift all li nodes within
                            if (_slate.Element.isElement(newParentNode) && newParentNode.type === 'li') {
                                // Lift the nested lis
                                _slate.Transforms.liftNodes(editor, {
                                    at: parentListItemPath,
                                    match: (node, path)=>{
                                        const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && path.length === parentListItemPath.length + 1 && node.type === 'li';
                                        return matches;
                                    }
                                });
                            }
                        } else {
                            _slate.Transforms.unwrapNodes(editor, {
                                at: parentListItemPath,
                                match: (node, path)=>{
                                    return _slate.Element.isElement(node) && node.type === 'li' && path.length === parentListItemPath.length;
                                }
                            });
                            _slate.Transforms.unwrapNodes(editor, {
                                match: (n)=>_slate.Element.isElement(n) && _listTypes.default.includes(n.type)
                            });
                        }
                    } else {
                        (0, _unwrapList.unwrapList)(editor, listPath);
                    }
                } else {
                    _slate.Transforms.unwrapNodes(editor, {
                        match: (n)=>_slate.Element.isElement(n) && n.type === indentType,
                        mode: 'lowest',
                        split: true
                    });
                }
            }
            if (dir === 'right') {
                const isCurrentlyOL = (0, _isActive.default)(editor, 'ol');
                const isCurrentlyUL = (0, _isActive.default)(editor, 'ul');
                if (isCurrentlyOL || isCurrentlyUL) {
                    // Get the path of the first selected li -
                    // Multiple lis could be selected
                    // and the selection may start in the middle of the first li
                    const [[, firstSelectedLIPath]] = Array.from(_slate.Editor.nodes(editor, {
                        match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                        mode: 'lowest'
                    }));
                    // Is the first selected li the first in its list?
                    const hasPrecedingLI = firstSelectedLIPath[firstSelectedLIPath.length - 1] > 0;
                    // If the first selected li is NOT the first in its list,
                    // we need to inject it into the prior li
                    if (hasPrecedingLI) {
                        const [, precedingLIPath] = _slate.Editor.previous(editor, {
                            at: firstSelectedLIPath
                        });
                        const [precedingLIChildren] = _slate.Editor.node(editor, [
                            ...precedingLIPath,
                            0
                        ]);
                        const precedingLIChildrenIsText = _slate.Text.isText(precedingLIChildren);
                        if (precedingLIChildrenIsText) {
                            // Wrap the prior li text content so that it can be nested next to a list
                            _slate.Transforms.wrapNodes(editor, {
                                children: []
                            }, {
                                at: [
                                    ...precedingLIPath,
                                    0
                                ]
                            });
                        }
                        // Move the selected lis after the prior li contents
                        _slate.Transforms.moveNodes(editor, {
                            match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                            mode: 'lowest',
                            to: [
                                ...precedingLIPath,
                                1
                            ]
                        });
                        // Wrap the selected lis in a new list
                        _slate.Transforms.wrapNodes(editor, {
                            children: [],
                            type: isCurrentlyOL ? 'ol' : 'ul'
                        }, {
                            match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                            mode: 'lowest'
                        });
                    } else {
                        // Otherwise, just wrap the node in a list / li
                        _slate.Transforms.wrapNodes(editor, {
                            children: [
                                {
                                    children: [],
                                    type: 'li'
                                }
                            ],
                            type: isCurrentlyOL ? 'ol' : 'ul'
                        }, {
                            match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                            mode: 'lowest'
                        });
                    }
                } else {
                    _slate.Transforms.wrapNodes(editor, {
                        children: [],
                        type: indentType
                    });
                }
            }
            _slatereact.ReactEditor.focus(editor);
        }, [
            editor
        ]);
        const canDeIndent = (0, _isActive.default)(editor, 'li') || (0, _isActive.default)(editor, indentType);
        return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("button", {
            className: [
                _Button.baseClass,
                !canDeIndent && `${_Button.baseClass}--disabled`
            ].filter(Boolean).join(' '),
            onClick: canDeIndent ? (e)=>handleIndent(e, 'left') : undefined,
            type: "button"
        }, /*#__PURE__*/ _react.default.createElement(_IndentLeft.default, null)), /*#__PURE__*/ _react.default.createElement("button", {
            className: _Button.baseClass,
            onClick: (e)=>handleIndent(e, 'right'),
            type: "button"
        }, /*#__PURE__*/ _react.default.createElement(_IndentRight.default, null)));
    },
    Element: IndentWithPadding
};
const _default = indent;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy9pbmRlbnQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgRWRpdG9yLCBFbGVtZW50LCBUZXh0LCBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnXG5pbXBvcnQgeyBSZWFjdEVkaXRvciwgdXNlU2xhdGUgfSBmcm9tICdzbGF0ZS1yZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBFbGVtZW50Tm9kZSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzJ1xuXG5pbXBvcnQgSW5kZW50TGVmdCBmcm9tICcuLi8uLi9pY29ucy9JbmRlbnRMZWZ0J1xuaW1wb3J0IEluZGVudFJpZ2h0IGZyb20gJy4uLy4uL2ljb25zL0luZGVudFJpZ2h0J1xuaW1wb3J0IHsgYmFzZUNsYXNzIH0gZnJvbSAnLi4vQnV0dG9uJ1xuaW1wb3J0IHsgZ2V0Q29tbW9uQmxvY2sgfSBmcm9tICcuLi9nZXRDb21tb25CbG9jaydcbmltcG9ydCBpc0VsZW1lbnRBY3RpdmUgZnJvbSAnLi4vaXNBY3RpdmUnXG5pbXBvcnQgeyBpc0Jsb2NrRWxlbWVudCB9IGZyb20gJy4uL2lzQmxvY2tFbGVtZW50J1xuaW1wb3J0IGxpc3RUeXBlcyBmcm9tICcuLi9saXN0VHlwZXMnXG5pbXBvcnQgeyB1bndyYXBMaXN0IH0gZnJvbSAnLi4vdW53cmFwTGlzdCdcblxuY29uc3QgaW5kZW50VHlwZSA9ICdpbmRlbnQnXG5cbmNvbnN0IEluZGVudFdpdGhQYWRkaW5nID0gKHsgYXR0cmlidXRlcywgY2hpbGRyZW4gfSkgPT4gKFxuICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmdMZWZ0OiAyNSB9fSB7Li4uYXR0cmlidXRlc30+XG4gICAge2NoaWxkcmVufVxuICA8L2Rpdj5cbilcblxuY29uc3QgaW5kZW50ID0ge1xuICBCdXR0b246ICgpID0+IHtcbiAgICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZSgpXG4gICAgY29uc3QgaGFuZGxlSW5kZW50ID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZSwgZGlyKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAgIGlmIChkaXIgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnbGknKSkge1xuICAgICAgICAgICAgY29uc3QgWywgbGlzdFBhdGhdID0gZ2V0Q29tbW9uQmxvY2soXG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgKG4pID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIGxpc3RUeXBlcy5pbmNsdWRlcyhuLnR5cGUpLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkUGFyZW50TGlzdCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IGxpc3RQYXRoLFxuICAgICAgICAgICAgICBtYXRjaDogKG46IEVsZW1lbnROb2RlKSA9PiAhRWRpdG9yLmlzRWRpdG9yKG4pICYmIGlzQmxvY2tFbGVtZW50KGVkaXRvciwgbiksXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZFBhcmVudExpc3QpIHtcbiAgICAgICAgICAgICAgY29uc3QgW3BhcmVudExpc3RJdGVtLCBwYXJlbnRMaXN0SXRlbVBhdGhdID0gbWF0Y2hlZFBhcmVudExpc3RcblxuICAgICAgICAgICAgICBpZiAocGFyZW50TGlzdEl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBuZXN0ZWQgbGlzdFxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGxpc3RUeXBlcy5pbmNsdWRlcyhub2RlLnR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgcGF0aC5sZW5ndGggPT09IHBhcmVudExpc3RJdGVtUGF0aC5sZW5ndGggKyAxXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIC8vIFNldCBsaSB0eXBlIG9uIGFueSBjaGlsZHJlbiB0aGF0IGRvbid0IGhhdmUgYSB0eXBlXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhcbiAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2xpJyB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDogKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgIT09ICdsaScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubGVuZ3RoID09PSBwYXJlbnRMaXN0SXRlbVBhdGgubGVuZ3RoICsgMVxuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IGxpc3QgaXRlbSBwYXRoIGhhcyBjaGFuZ2VkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWZldGNoIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGNvbnN0IFtuZXdQYXJlbnROb2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGFyZW50TGlzdEl0ZW1QYXRoKVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBub2RlIGlzIGFuIGxpLFxuICAgICAgICAgICAgICAgIC8vIGxpZnQgYWxsIGxpIG5vZGVzIHdpdGhpblxuICAgICAgICAgICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChuZXdQYXJlbnROb2RlKSAmJiBuZXdQYXJlbnROb2RlLnR5cGUgPT09ICdsaScpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExpZnQgdGhlIG5lc3RlZCBsaXNcbiAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMubGlmdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDogKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxlbmd0aCA9PT0gcGFyZW50TGlzdEl0ZW1QYXRoLmxlbmd0aCArIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gJ2xpJ1xuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgPT09ICdsaScgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxlbmd0aCA9PT0gcGFyZW50TGlzdEl0ZW1QYXRoLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBsaXN0VHlwZXMuaW5jbHVkZXMobi50eXBlKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bndyYXBMaXN0KGVkaXRvciwgbGlzdFBhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hdGNoOiAobikgPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgbi50eXBlID09PSBpbmRlbnRUeXBlLFxuICAgICAgICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXIgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBjb25zdCBpc0N1cnJlbnRseU9MID0gaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ29sJylcbiAgICAgICAgICBjb25zdCBpc0N1cnJlbnRseVVMID0gaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ3VsJylcblxuICAgICAgICAgIGlmIChpc0N1cnJlbnRseU9MIHx8IGlzQ3VycmVudGx5VUwpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGF0aCBvZiB0aGUgZmlyc3Qgc2VsZWN0ZWQgbGkgLVxuICAgICAgICAgICAgLy8gTXVsdGlwbGUgbGlzIGNvdWxkIGJlIHNlbGVjdGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHNlbGVjdGlvbiBtYXkgc3RhcnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgZmlyc3QgbGlcbiAgICAgICAgICAgIGNvbnN0IFtbLCBmaXJzdFNlbGVjdGVkTElQYXRoXV0gPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgICBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdsaScsXG4gICAgICAgICAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAvLyBJcyB0aGUgZmlyc3Qgc2VsZWN0ZWQgbGkgdGhlIGZpcnN0IGluIGl0cyBsaXN0P1xuICAgICAgICAgICAgY29uc3QgaGFzUHJlY2VkaW5nTEkgPSBmaXJzdFNlbGVjdGVkTElQYXRoW2ZpcnN0U2VsZWN0ZWRMSVBhdGgubGVuZ3RoIC0gMV0gPiAwXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBzZWxlY3RlZCBsaSBpcyBOT1QgdGhlIGZpcnN0IGluIGl0cyBsaXN0LFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbmplY3QgaXQgaW50byB0aGUgcHJpb3IgbGlcbiAgICAgICAgICAgIGlmIChoYXNQcmVjZWRpbmdMSSkge1xuICAgICAgICAgICAgICBjb25zdCBbLCBwcmVjZWRpbmdMSVBhdGhdID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBmaXJzdFNlbGVjdGVkTElQYXRoLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGNvbnN0IFtwcmVjZWRpbmdMSUNoaWxkcmVuXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgWy4uLnByZWNlZGluZ0xJUGF0aCwgMF0pXG4gICAgICAgICAgICAgIGNvbnN0IHByZWNlZGluZ0xJQ2hpbGRyZW5Jc1RleHQgPSBUZXh0LmlzVGV4dChwcmVjZWRpbmdMSUNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGlmIChwcmVjZWRpbmdMSUNoaWxkcmVuSXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCB0aGUgcHJpb3IgbGkgdGV4dCBjb250ZW50IHNvIHRoYXQgaXQgY2FuIGJlIG5lc3RlZCBuZXh0IHRvIGEgbGlzdFxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgeyBjaGlsZHJlbjogW10gfSwgeyBhdDogWy4uLnByZWNlZGluZ0xJUGF0aCwgMF0gfSlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHNlbGVjdGVkIGxpcyBhZnRlciB0aGUgcHJpb3IgbGkgY29udGVudHNcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdsaScsXG4gICAgICAgICAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgICAgICAgICAgdG86IFsuLi5wcmVjZWRpbmdMSVBhdGgsIDFdLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIC8vIFdyYXAgdGhlIHNlbGVjdGVkIGxpcyBpbiBhIG5ldyBsaXN0XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgICB0eXBlOiBpc0N1cnJlbnRseU9MID8gJ29sJyA6ICd1bCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2xpJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCB3cmFwIHRoZSBub2RlIGluIGEgbGlzdCAvIGxpXG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW3sgY2hpbGRyZW46IFtdLCB0eXBlOiAnbGknIH1dLFxuICAgICAgICAgICAgICAgICAgdHlwZTogaXNDdXJyZW50bHlPTCA/ICdvbCcgOiAndWwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdsaScsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgeyBjaGlsZHJlbjogW10sIHR5cGU6IGluZGVudFR5cGUgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWFjdEVkaXRvci5mb2N1cyhlZGl0b3IpXG4gICAgICB9LFxuICAgICAgW2VkaXRvcl0sXG4gICAgKVxuXG4gICAgY29uc3QgY2FuRGVJbmRlbnQgPSBpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnbGknKSB8fCBpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCBpbmRlbnRUeXBlKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT17W2Jhc2VDbGFzcywgIWNhbkRlSW5kZW50ICYmIGAke2Jhc2VDbGFzc30tLWRpc2FibGVkYF1cbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyl9XG4gICAgICAgICAgb25DbGljaz17Y2FuRGVJbmRlbnQgPyAoZSkgPT4gaGFuZGxlSW5kZW50KGUsICdsZWZ0JykgOiB1bmRlZmluZWR9XG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5kZW50TGVmdCAvPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2Jhc2VDbGFzc30gb25DbGljaz17KGUpID0+IGhhbmRsZUluZGVudChlLCAncmlnaHQnKX0gdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICAgIDxJbmRlbnRSaWdodCAvPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgKVxuICB9LFxuICBFbGVtZW50OiBJbmRlbnRXaXRoUGFkZGluZyxcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5kZW50XG4iXSwibmFtZXMiOlsiaW5kZW50VHlwZSIsIkluZGVudFdpdGhQYWRkaW5nIiwiYXR0cmlidXRlcyIsImNoaWxkcmVuIiwiZGl2Iiwic3R5bGUiLCJwYWRkaW5nTGVmdCIsImluZGVudCIsIkJ1dHRvbiIsImVkaXRvciIsInVzZVNsYXRlIiwiaGFuZGxlSW5kZW50IiwidXNlQ2FsbGJhY2siLCJlIiwiZGlyIiwicHJldmVudERlZmF1bHQiLCJpc0VsZW1lbnRBY3RpdmUiLCJsaXN0UGF0aCIsImdldENvbW1vbkJsb2NrIiwibiIsIkVsZW1lbnQiLCJpc0VsZW1lbnQiLCJsaXN0VHlwZXMiLCJpbmNsdWRlcyIsInR5cGUiLCJtYXRjaGVkUGFyZW50TGlzdCIsIkVkaXRvciIsImFib3ZlIiwiYXQiLCJtYXRjaCIsImlzRWRpdG9yIiwiaXNCbG9ja0VsZW1lbnQiLCJwYXJlbnRMaXN0SXRlbSIsInBhcmVudExpc3RJdGVtUGF0aCIsImxlbmd0aCIsIlRyYW5zZm9ybXMiLCJ1bndyYXBOb2RlcyIsIm5vZGUiLCJwYXRoIiwibWF0Y2hlcyIsInNldE5vZGVzIiwibmV3UGFyZW50Tm9kZSIsImxpZnROb2RlcyIsInVud3JhcExpc3QiLCJtb2RlIiwic3BsaXQiLCJpc0N1cnJlbnRseU9MIiwiaXNDdXJyZW50bHlVTCIsImZpcnN0U2VsZWN0ZWRMSVBhdGgiLCJBcnJheSIsImZyb20iLCJub2RlcyIsImhhc1ByZWNlZGluZ0xJIiwicHJlY2VkaW5nTElQYXRoIiwicHJldmlvdXMiLCJwcmVjZWRpbmdMSUNoaWxkcmVuIiwicHJlY2VkaW5nTElDaGlsZHJlbklzVGV4dCIsIlRleHQiLCJpc1RleHQiLCJ3cmFwTm9kZXMiLCJtb3ZlTm9kZXMiLCJ0byIsIlJlYWN0RWRpdG9yIiwiZm9jdXMiLCJjYW5EZUluZGVudCIsIlJlYWN0IiwiRnJhZ21lbnQiLCJidXR0b24iLCJjbGFzc05hbWUiLCJiYXNlQ2xhc3MiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIm9uQ2xpY2siLCJ1bmRlZmluZWQiLCJJbmRlbnRMZWZ0IiwiSW5kZW50UmlnaHQiXSwibWFwcGluZ3MiOiI7Ozs7K0JBaU9BOzs7ZUFBQTs7OytEQWpPbUM7dUJBQ2U7NEJBQ1o7bUVBSWY7b0VBQ0M7d0JBQ0U7Z0NBQ0s7aUVBQ0g7Z0NBQ0c7a0VBQ1Q7NEJBQ0s7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTNCLE1BQU1BLGFBQWE7QUFFbkIsTUFBTUMsb0JBQW9CLENBQUMsRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUUsaUJBQ2pELDZCQUFDQztRQUFJQyxPQUFPO1lBQUVDLGFBQWE7UUFBRztRQUFJLEdBQUdKLFVBQVU7T0FDNUNDO0FBSUwsTUFBTUksU0FBUztJQUNiQyxRQUFRO1FBQ04sTUFBTUMsU0FBU0MsSUFBQUEsb0JBQVE7UUFDdkIsTUFBTUMsZUFBZUMsSUFBQUEsa0JBQVcsRUFDOUIsQ0FBQ0MsR0FBR0M7WUFDRkQsRUFBRUUsY0FBYztZQUVoQixJQUFJRCxRQUFRLFFBQVE7Z0JBQ2xCLElBQUlFLElBQUFBLGlCQUFlLEVBQUNQLFFBQVEsT0FBTztvQkFDakMsTUFBTSxHQUFHUSxTQUFTLEdBQUdDLElBQUFBLDhCQUFjLEVBQ2pDVCxRQUNBLENBQUNVLElBQU1DLGNBQU8sQ0FBQ0MsU0FBUyxDQUFDRixNQUFNRyxrQkFBUyxDQUFDQyxRQUFRLENBQUNKLEVBQUVLLElBQUk7b0JBRzFELE1BQU1DLG9CQUFvQkMsYUFBTSxDQUFDQyxLQUFLLENBQUNsQixRQUFRO3dCQUM3Q21CLElBQUlYO3dCQUNKWSxPQUFPLENBQUNWLElBQW1CLENBQUNPLGFBQU0sQ0FBQ0ksUUFBUSxDQUFDWCxNQUFNWSxJQUFBQSw4QkFBYyxFQUFDdEIsUUFBUVU7b0JBQzNFO29CQUVBLElBQUlNLG1CQUFtQjt3QkFDckIsTUFBTSxDQUFDTyxnQkFBZ0JDLG1CQUFtQixHQUFHUjt3QkFFN0MsSUFBSU8sZUFBZTdCLFFBQVEsQ0FBQytCLE1BQU0sR0FBRyxHQUFHOzRCQUN0QyxxQkFBcUI7NEJBQ3JCQyxpQkFBVSxDQUFDQyxXQUFXLENBQUMzQixRQUFRO2dDQUM3Qm1CLElBQUlLO2dDQUNKSixPQUFPLENBQUNRLE1BQU1DO29DQUNaLE1BQU1DLFVBQ0osQ0FBQ2IsYUFBTSxDQUFDSSxRQUFRLENBQUNPLFNBQ2pCakIsY0FBTyxDQUFDQyxTQUFTLENBQUNnQixTQUNsQmYsa0JBQVMsQ0FBQ0MsUUFBUSxDQUFDYyxLQUFLYixJQUFJLEtBQzVCYyxLQUFLSixNQUFNLEtBQUtELG1CQUFtQkMsTUFBTSxHQUFHO29DQUU5QyxPQUFPSztnQ0FDVDs0QkFDRjs0QkFFQSxxREFBcUQ7NEJBQ3JESixpQkFBVSxDQUFDSyxRQUFRLENBQ2pCL0IsUUFDQTtnQ0FBRWUsTUFBTTs0QkFBSyxHQUNiO2dDQUNFSSxJQUFJSztnQ0FDSkosT0FBTyxDQUFDUSxNQUFNQztvQ0FDWixNQUFNQyxVQUNKLENBQUNiLGFBQU0sQ0FBQ0ksUUFBUSxDQUFDTyxTQUNqQmpCLGNBQU8sQ0FBQ0MsU0FBUyxDQUFDZ0IsU0FDbEJBLEtBQUtiLElBQUksS0FBSyxRQUNkYyxLQUFLSixNQUFNLEtBQUtELG1CQUFtQkMsTUFBTSxHQUFHO29DQUU5QyxPQUFPSztnQ0FDVDs0QkFDRjs0QkFHRixrREFBa0Q7NEJBQ2xELHlDQUF5Qzs0QkFDekMsTUFBTSxDQUFDRSxjQUFjLEdBQUdmLGFBQU0sQ0FBQ1csSUFBSSxDQUFDNUIsUUFBUXdCOzRCQUU1QywrQkFBK0I7NEJBQy9CLDJCQUEyQjs0QkFDM0IsSUFBSWIsY0FBTyxDQUFDQyxTQUFTLENBQUNvQixrQkFBa0JBLGNBQWNqQixJQUFJLEtBQUssTUFBTTtnQ0FDbkUsc0JBQXNCO2dDQUN0QlcsaUJBQVUsQ0FBQ08sU0FBUyxDQUFDakMsUUFBUTtvQ0FDM0JtQixJQUFJSztvQ0FDSkosT0FBTyxDQUFDUSxNQUFNQzt3Q0FDWixNQUFNQyxVQUNKLENBQUNiLGFBQU0sQ0FBQ0ksUUFBUSxDQUFDTyxTQUNqQmpCLGNBQU8sQ0FBQ0MsU0FBUyxDQUFDZ0IsU0FDbEJDLEtBQUtKLE1BQU0sS0FBS0QsbUJBQW1CQyxNQUFNLEdBQUcsS0FDNUNHLEtBQUtiLElBQUksS0FBSzt3Q0FFaEIsT0FBT2U7b0NBQ1Q7Z0NBQ0Y7NEJBQ0Y7d0JBQ0YsT0FBTzs0QkFDTEosaUJBQVUsQ0FBQ0MsV0FBVyxDQUFDM0IsUUFBUTtnQ0FDN0JtQixJQUFJSztnQ0FDSkosT0FBTyxDQUFDUSxNQUFNQztvQ0FDWixPQUNFbEIsY0FBTyxDQUFDQyxTQUFTLENBQUNnQixTQUNsQkEsS0FBS2IsSUFBSSxLQUFLLFFBQ2RjLEtBQUtKLE1BQU0sS0FBS0QsbUJBQW1CQyxNQUFNO2dDQUU3Qzs0QkFDRjs0QkFFQUMsaUJBQVUsQ0FBQ0MsV0FBVyxDQUFDM0IsUUFBUTtnQ0FDN0JvQixPQUFPLENBQUNWLElBQU1DLGNBQU8sQ0FBQ0MsU0FBUyxDQUFDRixNQUFNRyxrQkFBUyxDQUFDQyxRQUFRLENBQUNKLEVBQUVLLElBQUk7NEJBQ2pFO3dCQUNGO29CQUNGLE9BQU87d0JBQ0xtQixJQUFBQSxzQkFBVSxFQUFDbEMsUUFBUVE7b0JBQ3JCO2dCQUNGLE9BQU87b0JBQ0xrQixpQkFBVSxDQUFDQyxXQUFXLENBQUMzQixRQUFRO3dCQUM3Qm9CLE9BQU8sQ0FBQ1YsSUFBTUMsY0FBTyxDQUFDQyxTQUFTLENBQUNGLE1BQU1BLEVBQUVLLElBQUksS0FBS3hCO3dCQUNqRDRDLE1BQU07d0JBQ05DLE9BQU87b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUVBLElBQUkvQixRQUFRLFNBQVM7Z0JBQ25CLE1BQU1nQyxnQkFBZ0I5QixJQUFBQSxpQkFBZSxFQUFDUCxRQUFRO2dCQUM5QyxNQUFNc0MsZ0JBQWdCL0IsSUFBQUEsaUJBQWUsRUFBQ1AsUUFBUTtnQkFFOUMsSUFBSXFDLGlCQUFpQkMsZUFBZTtvQkFDbEMsMENBQTBDO29CQUMxQyxpQ0FBaUM7b0JBQ2pDLDREQUE0RDtvQkFDNUQsTUFBTSxDQUFDLEdBQUdDLG9CQUFvQixDQUFDLEdBQUdDLE1BQU1DLElBQUksQ0FDMUN4QixhQUFNLENBQUN5QixLQUFLLENBQUMxQyxRQUFRO3dCQUNuQm9CLE9BQU8sQ0FBQ1EsT0FBU2pCLGNBQU8sQ0FBQ0MsU0FBUyxDQUFDZ0IsU0FBU0EsS0FBS2IsSUFBSSxLQUFLO3dCQUMxRG9CLE1BQU07b0JBQ1I7b0JBR0Ysa0RBQWtEO29CQUNsRCxNQUFNUSxpQkFBaUJKLG1CQUFtQixDQUFDQSxvQkFBb0JkLE1BQU0sR0FBRyxFQUFFLEdBQUc7b0JBRTdFLHlEQUF5RDtvQkFDekQseUNBQXlDO29CQUN6QyxJQUFJa0IsZ0JBQWdCO3dCQUNsQixNQUFNLEdBQUdDLGdCQUFnQixHQUFHM0IsYUFBTSxDQUFDNEIsUUFBUSxDQUFDN0MsUUFBUTs0QkFDbERtQixJQUFJb0I7d0JBQ047d0JBRUEsTUFBTSxDQUFDTyxvQkFBb0IsR0FBRzdCLGFBQU0sQ0FBQ1csSUFBSSxDQUFDNUIsUUFBUTsrQkFBSTRDOzRCQUFpQjt5QkFBRTt3QkFDekUsTUFBTUcsNEJBQTRCQyxXQUFJLENBQUNDLE1BQU0sQ0FBQ0g7d0JBRTlDLElBQUlDLDJCQUEyQjs0QkFDN0IseUVBQXlFOzRCQUN6RXJCLGlCQUFVLENBQUN3QixTQUFTLENBQUNsRCxRQUFRO2dDQUFFTixVQUFVLEVBQUU7NEJBQUMsR0FBRztnQ0FBRXlCLElBQUk7dUNBQUl5QjtvQ0FBaUI7aUNBQUU7NEJBQUM7d0JBQy9FO3dCQUVBLG9EQUFvRDt3QkFDcERsQixpQkFBVSxDQUFDeUIsU0FBUyxDQUFDbkQsUUFBUTs0QkFDM0JvQixPQUFPLENBQUNRLE9BQVNqQixjQUFPLENBQUNDLFNBQVMsQ0FBQ2dCLFNBQVNBLEtBQUtiLElBQUksS0FBSzs0QkFDMURvQixNQUFNOzRCQUNOaUIsSUFBSTttQ0FBSVI7Z0NBQWlCOzZCQUFFO3dCQUM3Qjt3QkFFQSxzQ0FBc0M7d0JBQ3RDbEIsaUJBQVUsQ0FBQ3dCLFNBQVMsQ0FDbEJsRCxRQUNBOzRCQUNFTixVQUFVLEVBQUU7NEJBQ1pxQixNQUFNc0IsZ0JBQWdCLE9BQU87d0JBQy9CLEdBQ0E7NEJBQ0VqQixPQUFPLENBQUNRLE9BQVNqQixjQUFPLENBQUNDLFNBQVMsQ0FBQ2dCLFNBQVNBLEtBQUtiLElBQUksS0FBSzs0QkFDMURvQixNQUFNO3dCQUNSO29CQUVKLE9BQU87d0JBQ0wsK0NBQStDO3dCQUMvQ1QsaUJBQVUsQ0FBQ3dCLFNBQVMsQ0FDbEJsRCxRQUNBOzRCQUNFTixVQUFVO2dDQUFDO29DQUFFQSxVQUFVLEVBQUU7b0NBQUVxQixNQUFNO2dDQUFLOzZCQUFFOzRCQUN4Q0EsTUFBTXNCLGdCQUFnQixPQUFPO3dCQUMvQixHQUNBOzRCQUNFakIsT0FBTyxDQUFDUSxPQUFTakIsY0FBTyxDQUFDQyxTQUFTLENBQUNnQixTQUFTQSxLQUFLYixJQUFJLEtBQUs7NEJBQzFEb0IsTUFBTTt3QkFDUjtvQkFFSjtnQkFDRixPQUFPO29CQUNMVCxpQkFBVSxDQUFDd0IsU0FBUyxDQUFDbEQsUUFBUTt3QkFBRU4sVUFBVSxFQUFFO3dCQUFFcUIsTUFBTXhCO29CQUFXO2dCQUNoRTtZQUNGO1lBRUE4RCx1QkFBVyxDQUFDQyxLQUFLLENBQUN0RDtRQUNwQixHQUNBO1lBQUNBO1NBQU87UUFHVixNQUFNdUQsY0FBY2hELElBQUFBLGlCQUFlLEVBQUNQLFFBQVEsU0FBU08sSUFBQUEsaUJBQWUsRUFBQ1AsUUFBUVQ7UUFFN0UscUJBQ0UsNkJBQUNpRSxjQUFLLENBQUNDLFFBQVEsc0JBQ2IsNkJBQUNDO1lBQ0NDLFdBQVc7Z0JBQUNDLGlCQUFTO2dCQUFFLENBQUNMLGVBQWUsQ0FBQyxFQUFFSyxpQkFBUyxDQUFDLFVBQVUsQ0FBQzthQUFDLENBQzdEQyxNQUFNLENBQUNDLFNBQ1BDLElBQUksQ0FBQztZQUNSQyxTQUFTVCxjQUFjLENBQUNuRCxJQUFNRixhQUFhRSxHQUFHLFVBQVU2RDtZQUN4RGxELE1BQUs7eUJBRUwsNkJBQUNtRCxtQkFBVSx3QkFFYiw2QkFBQ1I7WUFBT0MsV0FBV0MsaUJBQVM7WUFBRUksU0FBUyxDQUFDNUQsSUFBTUYsYUFBYUUsR0FBRztZQUFVVyxNQUFLO3lCQUMzRSw2QkFBQ29ELG9CQUFXO0lBSXBCO0lBQ0F4RCxTQUFTbkI7QUFDWDtNQUVBLFdBQWVNIn0=