'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "LinkButton", {
    enumerable: true,
    get: function() {
        return LinkButton;
    }
});
const _modal = require("@faceless-ui/modal");
const _elements = require("payload/components/elements");
const _forms = require("payload/components/forms");
const _utilities = require("payload/components/utilities");
const _config = require("payload/config");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _slate = require("slate");
const _slatereact = require("slate-react");
const _Link = /*#__PURE__*/ _interop_require_default(require("../../../icons/Link"));
const _Button = /*#__PURE__*/ _interop_require_default(require("../../Button"));
const _isActive = /*#__PURE__*/ _interop_require_default(require("../../isActive"));
const _LinkDrawer = require("../LinkDrawer");
const _utilities1 = require("../utilities");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * This function is called when an new link is created - not when an existing link is edited.
 */ const insertLink = (editor, fields)=>{
    const isCollapsed = editor.selection && _slate.Range.isCollapsed(editor.selection);
    const data = (0, _forms.reduceFieldsToValues)(fields, true);
    const newLink = {
        children: [],
        doc: data.doc,
        fields: data.fields,
        linkType: data.linkType,
        newTab: data.newTab,
        type: 'link',
        url: data.url
    };
    if (isCollapsed || !editor.selection) {
        // If selection anchor and focus are the same,
        // Just inject a new node with children already set
        _slate.Transforms.insertNodes(editor, {
            ...newLink,
            children: [
                {
                    text: String(data.text)
                }
            ]
        });
    } else if (editor.selection) {
        // Otherwise we need to wrap the selected node in a link,
        // Delete its old text,
        // Move the selection one position forward into the link,
        // And insert the text back into the new link
        _slate.Transforms.wrapNodes(editor, newLink, {
            split: true
        });
        _slate.Transforms.delete(editor, {
            at: editor.selection.focus.path,
            unit: 'word'
        });
        _slate.Transforms.move(editor, {
            distance: 1,
            unit: 'offset'
        });
        _slate.Transforms.insertText(editor, String(data.text), {
            at: editor.selection.focus.path
        });
    }
    _slatereact.ReactEditor.focus(editor);
};
const LinkButton = ({ fieldProps })=>{
    const customFieldSchema = fieldProps?.admin?.link?.fields;
    const { user } = (0, _utilities.useAuth)();
    const { code: locale } = (0, _utilities.useLocale)();
    const [initialState, setInitialState] = (0, _react.useState)({});
    const { i18n, t } = (0, _reacti18next.useTranslation)([
        'upload',
        'general'
    ]);
    const editor = (0, _slatereact.useSlate)();
    const config = (0, _utilities.useConfig)();
    const [fieldSchema] = (0, _react.useState)(()=>{
        const fieldsUnsanitized = (0, _utilities1.transformExtraFields)(customFieldSchema, config, i18n);
        // Sanitize custom fields here
        const validRelationships = config.collections.map((c)=>c.slug) || [];
        const fields = (0, _config.sanitizeFields)({
            config: config,
            fields: fieldsUnsanitized,
            validRelationships
        });
        return fields;
    });
    const { closeModal, openModal } = (0, _modal.useModal)();
    const drawerSlug = (0, _elements.useDrawerSlug)('rich-text-link');
    const { getDocPreferences } = (0, _utilities.useDocumentInfo)();
    return /*#__PURE__*/ _react.default.createElement(_react.Fragment, null, /*#__PURE__*/ _react.default.createElement(_Button.default, {
        className: "link",
        format: "link",
        onClick: async ()=>{
            if ((0, _isActive.default)(editor, 'link')) {
                (0, _utilities1.unwrapLink)(editor);
            } else {
                openModal(drawerSlug);
                const isCollapsed = editor.selection && _slate.Range.isCollapsed(editor.selection);
                if (!isCollapsed) {
                    const data = {
                        text: editor.selection ? _slate.Editor.string(editor, editor.selection) : ''
                    };
                    const preferences = await getDocPreferences();
                    const state = await (0, _utilities.buildStateFromSchema)({
                        config,
                        data,
                        fieldSchema,
                        locale,
                        operation: 'create',
                        preferences,
                        t,
                        user
                    });
                    setInitialState(state);
                }
            }
        },
        tooltip: t('fields:addLink')
    }, /*#__PURE__*/ _react.default.createElement(_Link.default, null)), /*#__PURE__*/ _react.default.createElement(_LinkDrawer.LinkDrawer, {
        drawerSlug: drawerSlug,
        fieldSchema: fieldSchema,
        handleClose: ()=>{
            closeModal(drawerSlug);
        },
        handleModalSubmit: (fields)=>{
            insertLink(editor, fields);
            closeModal(drawerSlug);
        },
        initialState: initialState
    }));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy9saW5rL0J1dHRvbi9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgRmllbGRzIH0gZnJvbSAncGF5bG9hZC90eXBlcydcblxuaW1wb3J0IHsgdXNlTW9kYWwgfSBmcm9tICdAZmFjZWxlc3MtdWkvbW9kYWwnXG5pbXBvcnQgeyB1c2VEcmF3ZXJTbHVnIH0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL2VsZW1lbnRzJ1xuaW1wb3J0IHsgcmVkdWNlRmllbGRzVG9WYWx1ZXMgfSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMvZm9ybXMnXG5pbXBvcnQge1xuICBidWlsZFN0YXRlRnJvbVNjaGVtYSxcbiAgdXNlQXV0aCxcbiAgdXNlQ29uZmlnLFxuICB1c2VEb2N1bWVudEluZm8sXG4gIHVzZUxvY2FsZSxcbn0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL3V0aWxpdGllcydcbmltcG9ydCB7IHNhbml0aXplRmllbGRzIH0gZnJvbSAncGF5bG9hZC9jb25maWcnXG5pbXBvcnQgUmVhY3QsIHsgRnJhZ21lbnQsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5pbXBvcnQgeyBFZGl0b3IsIFJhbmdlLCBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnXG5pbXBvcnQgeyBSZWFjdEVkaXRvciwgdXNlU2xhdGUgfSBmcm9tICdzbGF0ZS1yZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBGaWVsZFByb3BzIH0gZnJvbSAnLi4vLi4vLi4vLi4vdHlwZXMnXG5cbmltcG9ydCBMaW5rSWNvbiBmcm9tICcuLi8uLi8uLi9pY29ucy9MaW5rJ1xuaW1wb3J0IEVsZW1lbnRCdXR0b24gZnJvbSAnLi4vLi4vQnV0dG9uJ1xuaW1wb3J0IGlzRWxlbWVudEFjdGl2ZSBmcm9tICcuLi8uLi9pc0FjdGl2ZSdcbmltcG9ydCB7IExpbmtEcmF3ZXIgfSBmcm9tICcuLi9MaW5rRHJhd2VyJ1xuaW1wb3J0IHsgdHJhbnNmb3JtRXh0cmFGaWVsZHMsIHVud3JhcExpbmsgfSBmcm9tICcuLi91dGlsaXRpZXMnXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhbiBuZXcgbGluayBpcyBjcmVhdGVkIC0gbm90IHdoZW4gYW4gZXhpc3RpbmcgbGluayBpcyBlZGl0ZWQuXG4gKi9cbmNvbnN0IGluc2VydExpbmsgPSAoZWRpdG9yLCBmaWVsZHMpID0+IHtcbiAgY29uc3QgaXNDb2xsYXBzZWQgPSBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pXG4gIGNvbnN0IGRhdGEgPSByZWR1Y2VGaWVsZHNUb1ZhbHVlcyhmaWVsZHMsIHRydWUpXG5cbiAgY29uc3QgbmV3TGluayA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgZG9jOiBkYXRhLmRvYyxcbiAgICBmaWVsZHM6IGRhdGEuZmllbGRzLCAvLyBBbnkgY3VzdG9tIHVzZXItYWRkZWQgZmllbGRzIGFyZSBwYXJ0IG9mIGRhdGEuZmllbGRzXG4gICAgbGlua1R5cGU6IGRhdGEubGlua1R5cGUsXG4gICAgbmV3VGFiOiBkYXRhLm5ld1RhYixcbiAgICB0eXBlOiAnbGluaycsXG4gICAgdXJsOiBkYXRhLnVybCxcbiAgfVxuXG4gIGlmIChpc0NvbGxhcHNlZCB8fCAhZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIC8vIElmIHNlbGVjdGlvbiBhbmNob3IgYW5kIGZvY3VzIGFyZSB0aGUgc2FtZSxcbiAgICAvLyBKdXN0IGluamVjdCBhIG5ldyBub2RlIHdpdGggY2hpbGRyZW4gYWxyZWFkeSBzZXRcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgLi4ubmV3TGluayxcbiAgICAgIGNoaWxkcmVuOiBbeyB0ZXh0OiBTdHJpbmcoZGF0YS50ZXh0KSB9XSxcbiAgICB9KVxuICB9IGVsc2UgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3cmFwIHRoZSBzZWxlY3RlZCBub2RlIGluIGEgbGluayxcbiAgICAvLyBEZWxldGUgaXRzIG9sZCB0ZXh0LFxuICAgIC8vIE1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcG9zaXRpb24gZm9yd2FyZCBpbnRvIHRoZSBsaW5rLFxuICAgIC8vIEFuZCBpbnNlcnQgdGhlIHRleHQgYmFjayBpbnRvIHRoZSBuZXcgbGlua1xuICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgbmV3TGluaywgeyBzcGxpdDogdHJ1ZSB9KVxuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwgeyBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLCB1bml0OiAnd29yZCcgfSlcbiAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7IGRpc3RhbmNlOiAxLCB1bml0OiAnb2Zmc2V0JyB9KVxuICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIFN0cmluZyhkYXRhLnRleHQpLCB7IGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGggfSlcbiAgfVxuXG4gIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcilcbn1cblxuZXhwb3J0IGNvbnN0IExpbmtCdXR0b246IFJlYWN0LkZDPHtcbiAgZmllbGRQcm9wczogRmllbGRQcm9wc1xuICBwYXRoOiBzdHJpbmdcbn0+ID0gKHsgZmllbGRQcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGN1c3RvbUZpZWxkU2NoZW1hID0gZmllbGRQcm9wcz8uYWRtaW4/Lmxpbms/LmZpZWxkc1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZUF1dGgoKVxuICBjb25zdCB7IGNvZGU6IGxvY2FsZSB9ID0gdXNlTG9jYWxlKClcbiAgY29uc3QgW2luaXRpYWxTdGF0ZSwgc2V0SW5pdGlhbFN0YXRlXSA9IHVzZVN0YXRlPEZpZWxkcz4oe30pXG5cbiAgY29uc3QgeyBpMThuLCB0IH0gPSB1c2VUcmFuc2xhdGlvbihbJ3VwbG9hZCcsICdnZW5lcmFsJ10pXG4gIGNvbnN0IGVkaXRvciA9IHVzZVNsYXRlKClcbiAgY29uc3QgY29uZmlnID0gdXNlQ29uZmlnKClcblxuICBjb25zdCBbZmllbGRTY2hlbWFdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgIGNvbnN0IGZpZWxkc1Vuc2FuaXRpemVkID0gdHJhbnNmb3JtRXh0cmFGaWVsZHMoY3VzdG9tRmllbGRTY2hlbWEsIGNvbmZpZywgaTE4bilcbiAgICAvLyBTYW5pdGl6ZSBjdXN0b20gZmllbGRzIGhlcmVcbiAgICBjb25zdCB2YWxpZFJlbGF0aW9uc2hpcHMgPSBjb25maWcuY29sbGVjdGlvbnMubWFwKChjKSA9PiBjLnNsdWcpIHx8IFtdXG4gICAgY29uc3QgZmllbGRzID0gc2FuaXRpemVGaWVsZHMoe1xuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBmaWVsZHM6IGZpZWxkc1Vuc2FuaXRpemVkLFxuICAgICAgdmFsaWRSZWxhdGlvbnNoaXBzLFxuICAgIH0pXG5cbiAgICByZXR1cm4gZmllbGRzXG4gIH0pXG5cbiAgY29uc3QgeyBjbG9zZU1vZGFsLCBvcGVuTW9kYWwgfSA9IHVzZU1vZGFsKClcbiAgY29uc3QgZHJhd2VyU2x1ZyA9IHVzZURyYXdlclNsdWcoJ3JpY2gtdGV4dC1saW5rJylcbiAgY29uc3QgeyBnZXREb2NQcmVmZXJlbmNlcyB9ID0gdXNlRG9jdW1lbnRJbmZvKClcblxuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIDxFbGVtZW50QnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cImxpbmtcIlxuICAgICAgICBmb3JtYXQ9XCJsaW5rXCJcbiAgICAgICAgb25DbGljaz17YXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnbGluaycpKSB7XG4gICAgICAgICAgICB1bndyYXBMaW5rKGVkaXRvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3Blbk1vZGFsKGRyYXdlclNsdWcpXG5cbiAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKVxuXG4gICAgICAgICAgICBpZiAoIWlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogZWRpdG9yLnNlbGVjdGlvbiA/IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKSA6ICcnLFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgcHJlZmVyZW5jZXMgPSBhd2FpdCBnZXREb2NQcmVmZXJlbmNlcygpXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgYnVpbGRTdGF0ZUZyb21TY2hlbWEoe1xuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGZpZWxkU2NoZW1hLFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdjcmVhdGUnLFxuICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbFN0YXRlKHN0YXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgdG9vbHRpcD17dCgnZmllbGRzOmFkZExpbmsnKX1cbiAgICAgID5cbiAgICAgICAgPExpbmtJY29uIC8+XG4gICAgICA8L0VsZW1lbnRCdXR0b24+XG4gICAgICA8TGlua0RyYXdlclxuICAgICAgICBkcmF3ZXJTbHVnPXtkcmF3ZXJTbHVnfVxuICAgICAgICBmaWVsZFNjaGVtYT17ZmllbGRTY2hlbWF9XG4gICAgICAgIGhhbmRsZUNsb3NlPXsoKSA9PiB7XG4gICAgICAgICAgY2xvc2VNb2RhbChkcmF3ZXJTbHVnKVxuICAgICAgICB9fVxuICAgICAgICBoYW5kbGVNb2RhbFN1Ym1pdD17KGZpZWxkcykgPT4ge1xuICAgICAgICAgIGluc2VydExpbmsoZWRpdG9yLCBmaWVsZHMpXG4gICAgICAgICAgY2xvc2VNb2RhbChkcmF3ZXJTbHVnKVxuICAgICAgICB9fVxuICAgICAgICBpbml0aWFsU3RhdGU9e2luaXRpYWxTdGF0ZX1cbiAgICAgIC8+XG4gICAgPC9GcmFnbWVudD5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkxpbmtCdXR0b24iLCJpbnNlcnRMaW5rIiwiZWRpdG9yIiwiZmllbGRzIiwiaXNDb2xsYXBzZWQiLCJzZWxlY3Rpb24iLCJSYW5nZSIsImRhdGEiLCJyZWR1Y2VGaWVsZHNUb1ZhbHVlcyIsIm5ld0xpbmsiLCJjaGlsZHJlbiIsImRvYyIsImxpbmtUeXBlIiwibmV3VGFiIiwidHlwZSIsInVybCIsIlRyYW5zZm9ybXMiLCJpbnNlcnROb2RlcyIsInRleHQiLCJTdHJpbmciLCJ3cmFwTm9kZXMiLCJzcGxpdCIsImRlbGV0ZSIsImF0IiwiZm9jdXMiLCJwYXRoIiwidW5pdCIsIm1vdmUiLCJkaXN0YW5jZSIsImluc2VydFRleHQiLCJSZWFjdEVkaXRvciIsImZpZWxkUHJvcHMiLCJjdXN0b21GaWVsZFNjaGVtYSIsImFkbWluIiwibGluayIsInVzZXIiLCJ1c2VBdXRoIiwiY29kZSIsImxvY2FsZSIsInVzZUxvY2FsZSIsImluaXRpYWxTdGF0ZSIsInNldEluaXRpYWxTdGF0ZSIsInVzZVN0YXRlIiwiaTE4biIsInQiLCJ1c2VUcmFuc2xhdGlvbiIsInVzZVNsYXRlIiwiY29uZmlnIiwidXNlQ29uZmlnIiwiZmllbGRTY2hlbWEiLCJmaWVsZHNVbnNhbml0aXplZCIsInRyYW5zZm9ybUV4dHJhRmllbGRzIiwidmFsaWRSZWxhdGlvbnNoaXBzIiwiY29sbGVjdGlvbnMiLCJtYXAiLCJjIiwic2x1ZyIsInNhbml0aXplRmllbGRzIiwiY2xvc2VNb2RhbCIsIm9wZW5Nb2RhbCIsInVzZU1vZGFsIiwiZHJhd2VyU2x1ZyIsInVzZURyYXdlclNsdWciLCJnZXREb2NQcmVmZXJlbmNlcyIsInVzZURvY3VtZW50SW5mbyIsIkZyYWdtZW50IiwiRWxlbWVudEJ1dHRvbiIsImNsYXNzTmFtZSIsImZvcm1hdCIsIm9uQ2xpY2siLCJpc0VsZW1lbnRBY3RpdmUiLCJ1bndyYXBMaW5rIiwiRWRpdG9yIiwic3RyaW5nIiwicHJlZmVyZW5jZXMiLCJzdGF0ZSIsImJ1aWxkU3RhdGVGcm9tU2NoZW1hIiwib3BlcmF0aW9uIiwidG9vbHRpcCIsIkxpbmtJY29uIiwiTGlua0RyYXdlciIsImhhbmRsZUNsb3NlIiwiaGFuZGxlTW9kYWxTdWJtaXQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OzsrQkFrRWFBOzs7ZUFBQUE7Ozt1QkE5RFk7MEJBQ0s7dUJBQ087MkJBTzlCO3dCQUN3QjsrREFDVzs4QkFDWDt1QkFDVzs0QkFDSjs2REFJakI7K0RBQ0s7aUVBQ0U7NEJBQ0Q7NEJBQ3NCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVqRDs7Q0FFQyxHQUNELE1BQU1DLGFBQWEsQ0FBQ0MsUUFBUUM7SUFDMUIsTUFBTUMsY0FBY0YsT0FBT0csU0FBUyxJQUFJQyxZQUFLLENBQUNGLFdBQVcsQ0FBQ0YsT0FBT0csU0FBUztJQUMxRSxNQUFNRSxPQUFPQyxJQUFBQSwyQkFBb0IsRUFBQ0wsUUFBUTtJQUUxQyxNQUFNTSxVQUFVO1FBQ2RDLFVBQVUsRUFBRTtRQUNaQyxLQUFLSixLQUFLSSxHQUFHO1FBQ2JSLFFBQVFJLEtBQUtKLE1BQU07UUFDbkJTLFVBQVVMLEtBQUtLLFFBQVE7UUFDdkJDLFFBQVFOLEtBQUtNLE1BQU07UUFDbkJDLE1BQU07UUFDTkMsS0FBS1IsS0FBS1EsR0FBRztJQUNmO0lBRUEsSUFBSVgsZUFBZSxDQUFDRixPQUFPRyxTQUFTLEVBQUU7UUFD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